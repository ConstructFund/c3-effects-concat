{"all":[{"json":{"id":"alphaclamp","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"threshold","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"alphathreshold"},{"id":"lower-clamp","type":"percent","initial-value":0,"interpolatable":true,"uniform":"lowerclamp"},{"id":"upper-clamp","type":"percent","initial-value":1,"interpolatable":true,"uniform":"upperclamp"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Alpha clamp effect\r\nprecision mediump float;\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float alphathreshold;\r\nuniform lowp float lowerclamp;\r\nuniform lowp float upperclamp;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\t// Extract alpha and unpremultiply\r\n\tlowp float a = front.a;\r\n\tlowp vec4 unpremultiplied = front / a;\r\n\t\r\n\t// Apply threshold\r\n\ta = (a < alphathreshold ? lowerclamp : upperclamp);\r\n\t\r\n\t// Premultiply and apply clamped alpha\r\n\tfront *= a;\r\n\tfront.a = a;\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\talphathreshold : f32,\r\n\tlowerclamp : f32,\r\n\tupperclamp : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\r\n\t// Apply alpha threshold\r\n\tfront.a = select(shaderParams.upperclamp, shaderParams.lowerclamp, front.a < shaderParams.alphathreshold);\r\n\r\n\t// Output premultiplied with clamped alpha\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(front.rgb * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"blacknwhite","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"threshold","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"threshold"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Black & white effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float threshold;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\t// Calculate grayscale amount\r\n\tlowp float gray = front.r * 0.299 + front.g * 0.587 + front.b * 0.114;\r\n\t\r\n\t// Output either black or white\r\n\tif (gray < threshold)\r\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, front.a);\r\n\telse\r\n\t\tgl_FragColor = vec4(front.a, front.a, front.a, front.a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tthreshold : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve source pixel\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar a : f32 = front.a;\r\n\r\n\t// Calculate grayscale amount\r\n\tvar gray : f32 = c3_grayscale(front.rgb);\r\n\r\n\t// Output either black or white\r\n\tvar output : FragmentOutput;\r\n\toutput.color = select(vec4<f32>(a, a, a, a), vec4<f32>(0.0, 0.0, 0.0, a), gray < shaderParams.threshold);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"blacknwhitemask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"threshold","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"threshold"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Black & white mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform lowp float threshold;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Calculate grayscale amount\r\n\tlowp float gray = back.r * 0.299 + back.g * 0.587 + back.b * 0.114;\r\n\t\r\n\t// Output either black or white with foreground alpha intensity\r\n\tif (gray < threshold)\r\n\t\tgl_FragColor = mix(back, vec4(0.0, 0.0, 0.0, back.a), fronta);\r\n\telse\r\n\t\tgl_FragColor = mix(back, vec4(back.a, back.a, back.a, back.a), fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tthreshold : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\t// Calculate grayscale amount\r\n\tvar gray : f32 = c3_grayscale(back.rgb);\r\n\r\n\t// Output either black or white\r\n\tvar output : FragmentOutput;\r\n\toutput.color = select(vec4<f32>(back.a, back.a, back.a, back.a), vec4<f32>(0.0, 0.0, 0.0, back.a), gray < shaderParams.threshold);\r\n\r\n\t// Mix according to front alpha\r\n\toutput.color = mix(back, output.color, fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"blurhorizontal","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":8,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Blur horizontal effect\r\nvarying mediump vec2 vTex;\r\nuniform mediump sampler2D samplerFront;\r\n\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec4 sum = vec4(0.0);\r\n\tmediump float pixelWidth = pixelSize.x;\r\n\tmediump float halfPixelWidth = pixelWidth / 2.0;\r\n\t\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tsum += front * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\r\n\t\r\n\tgl_FragColor = mix(front, sum, intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelWidth : f32 = c3_getPixelSize(textureFront).x;\r\n\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tvar sum : vec4<f32> =\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\r\n\t\tfront * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, sum, shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"blurvertical","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":8},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Blur vertical effect\r\nvarying mediump vec2 vTex;\r\nuniform mediump sampler2D samplerFront;\r\n\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec4 sum = vec4(0.0);\r\n\tmediump float pixelHeight = pixelSize.y;\r\n\tmediump float halfPixelHeight = pixelHeight / 2.0;\r\n\t\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tsum += front * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\r\n\t\r\n\tgl_FragColor = mix(front, sum, intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelHeight : f32 = c3_getPixelSize(textureFront).y;\r\n\t\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\t// Add nine vertical samples, with mid-pixel sampling to get two pixels in one\r\n\tvar sum : vec4<f32> =\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\r\n\t\tfront * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, sum, shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"brightness","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"brightness","type":"percent","initial-value":1,"interpolatable":true,"uniform":"brightness"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Brightness effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float brightness;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= front.a;\r\n\t\r\n\tfront.rgb += (brightness - 1.0);\r\n\t\r\n\tfront.rgb *= a;\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tbrightness : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>((front.rgb + (shaderParams.brightness - 1.0)) * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"bulge","category":"distortion","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"radius","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"radius"},{"id":"scale","type":"percent","initial-value":0.4,"interpolatable":true,"uniform":"scale"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Bulge effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\n\r\nuniform mediump float radius;\r\nuniform mediump float scale;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 tex = (vTex - srcOriginStart) / srcOriginSize;\r\n\tmediump float dist = distance(vec2(0.5, 0.5), tex);\r\n\ttex -= vec2(0.5, 0.5);\r\n\t\r\n\tif (dist < radius)\r\n\t{\r\n\t\tmediump float percent = 1.0 - ((radius - dist) / radius) * scale;\r\n\t\tpercent = percent * percent;\r\n\r\n\t\ttex = tex * percent;\r\n\t}\r\n\t\r\n\ttex += vec2(0.5, 0.5);\r\n\ttex = clamp(tex, 0.0, 1.0);\t\t\t// ensure no sampling outside source rect\r\n\ttex = (tex * srcOriginSize) + srcOriginStart;\t// convert back relative to source rect\r\n\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"\r\n// Bulge effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n// Ported to WGSL from GLSL\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tradius : f32,\r\n\tscale : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tex : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\tvar dist : f32 = distance(vec2<f32>(0.5, 0.5), tex);\r\n\ttex = tex - 0.5;\r\n\r\n\tif (dist < shaderParams.radius)\r\n\t{\r\n\t\tvar percent : f32 = 1.0 - ((shaderParams.radius - dist) / shaderParams.radius) * shaderParams.scale;\r\n\t\tpercent = percent * percent;\r\n\t\t\r\n\t\ttex = tex * percent;\r\n\t}\r\n\r\n\ttex = tex + 0.5;\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\t\t// ensure no sampling outside source rect\r\n\ttex = c3_normToSrcOrigin(tex);\t\t// convert back relative to source rect\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"bumpmapping","category":"normal-mapping","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"light-x","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"lightx"},{"id":"light-y","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"lighty"},{"id":"light-z","type":"percent","initial-value":0.1,"interpolatable":true,"uniform":"lightz"},{"id":"intensity","type":"percent","initial-value":2.5,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Bumpmapping effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform mediump float lightx;\r\nuniform mediump float lighty;\r\nuniform mediump float lightz;\r\nuniform mediump float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tmediump vec3 normal = 2.0 * front.rgb - 1.0;\r\n\tmediump vec3 light = normalize(vec3(lightx - tex.x, lighty - tex.y, lightz));\r\n\tmediump float diffuse = clamp(dot(normal, light), 0.0, 1.0); \r\n\r\n\tgl_FragColor = intensity * back * diffuse;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tlightx : f32,\r\n\tlighty : f32,\r\n\tlightz : f32,\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar frontRgb : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV).rgb;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar normal : vec3<f32> = frontRgb * 2.0 - 1.0;\r\n\tvar light : vec3<f32> = normalize(vec3<f32>(shaderParams.lightx - tex.x, shaderParams.lighty - tex.y, shaderParams.lightz));\r\n\tvar diffuse : f32 = clamp(dot(normal, light), 0.0, 1.0);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = back * shaderParams.intensity * diffuse;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"burn","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Burn effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Burn blend\r\n\tfront.rgb = 1.0 - ((1.0 - back.rgb) / (front.rgb * front.a));\r\n\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Burn blend\r\n\t\tvec3<f32>(1.0) - ((vec3<f32>(1.0) - back.rgb) / (front.rgb * front.a)),\r\n\t\tfront.a\t\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"cga","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// CGA effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nvoid main(void)\r\n{\r\n\thighmedp vec2 sampleDivisor = vec2(1.0 / 200.0, 1.0 / 320.0);\r\n\r\n\thighmedp vec2 samplePos = vTex - mod(vTex, sampleDivisor);\r\n\thighmedp vec4 color = texture2D(samplerFront, samplePos);\r\n\r\n\tmediump vec4 colorCyan = vec4(85.0 / 255.0, 1.0, 1.0, 1.0);\r\n\tmediump vec4 colorMagenta = vec4(1.0, 85.0 / 255.0, 1.0, 1.0);\r\n\tmediump vec4 colorWhite = vec4(1.0, 1.0, 1.0, 1.0);\r\n\tmediump vec4 colorBlack = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n\tmediump vec4 endColor;\r\n\thighmedp float blackDistance = distance(color, colorBlack);\r\n\thighmedp float whiteDistance = distance(color, colorWhite);\r\n\thighmedp float magentaDistance = distance(color, colorMagenta);\r\n\thighmedp float cyanDistance = distance(color, colorCyan);\r\n\r\n\tmediump vec4 finalColor;\r\n\r\n\thighmedp float colorDistance = min(magentaDistance, cyanDistance);\r\n\tcolorDistance = min(colorDistance, whiteDistance);\r\n\tcolorDistance = min(colorDistance, blackDistance); \r\n\r\n\tif (colorDistance == blackDistance)\r\n\t\tfinalColor = colorBlack;\r\n\telse if (colorDistance == whiteDistance)\r\n\t\tfinalColor = colorWhite;\r\n\telse if (colorDistance == cyanDistance)\r\n\t\tfinalColor = colorCyan;\r\n\telse\r\n\t\tfinalColor = colorMagenta;\r\n\t\r\n\tfinalColor.rgb *= color.a;\r\n\tfinalColor.a = color.a;\r\n\tgl_FragColor = finalColor;\r\n}\r\n","wgsl":"\r\n// CGA effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n// Ported to WGSL from GLSL\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar sampleDivisor : vec2<f32> = vec2<f32>(1.0 / 200.0, 1.0 / 320.0);\r\n\tvar samplePos = sampleDivisor * floor(input.fragUV / sampleDivisor);\r\n\tvar color : vec4<f32> = textureSample(textureFront, samplerFront, samplePos);\r\n\r\n\tvar colorCyan : vec4<f32> = vec4<f32>(85.0 / 255.0, 1.0, 1.0, 1.0);\r\n\tvar colorMagenta : vec4<f32> = vec4<f32>(1.0, 85.0 / 255.0, 1.0, 1.0);\r\n\tvar colorWhite : vec4<f32> = vec4<f32>(1.0, 1.0, 1.0, 1.0);\r\n\tvar colorBlack : vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);\r\n\r\n\tvar blackDistance : f32 = distance(color, colorBlack);\r\n\tvar whiteDistance : f32 = distance(color, colorWhite);\r\n\tvar magentaDistance : f32 = distance(color, colorMagenta);\r\n\tvar cyanDistance : f32 = distance(color, colorCyan);\r\n\r\n\tvar colorDistance : f32 = min(min(blackDistance, whiteDistance), min(magentaDistance, cyanDistance));\r\n\r\n\tvar finalColor : vec4<f32>;\r\n\tif (colorDistance == blackDistance)\r\n\t{\r\n\t\tfinalColor = colorBlack;\r\n\t}\r\n\telse if (colorDistance == whiteDistance)\r\n\t{\r\n\t\tfinalColor = colorWhite;\r\n\t}\r\n\telse if (colorDistance == cyanDistance)\r\n\t{\r\n\t\tfinalColor = colorCyan;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfinalColor = colorMagenta;\r\n\t}\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(finalColor.rgb * color.a, color.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"colorblend","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Color effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nprecision mediump float;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\tvec3 fronthsl = rgb_to_hsl(front.rgb / front.a);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tvec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tvec3 backhsl = rgb_to_hsl(back.rgb / back.a);\r\n\r\n\t// Use hue and saturation of front and luminosity of back\r\n\tfronthsl = hsl_to_rgb(vec3(fronthsl.x, fronthsl.y, backhsl.z));\r\n\tfronthsl *= front.a;\r\n\r\n\tgl_FragColor = vec4(fronthsl.r, fronthsl.g, fronthsl.b, front.a) * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar fronthsl : vec3<f32> = c3_RGBtoHSL(front.rgb);\r\n\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\tvar backhsl : vec3<f32> = c3_RGBtoHSL(back.rgb);\r\n\r\n\t// Use hue and saturation of front and luminosity of back\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\tc3_HSLtoRGB(vec3<f32>(fronthsl.x, fronthsl.y, backhsl.z)) * front.a,\r\n\t\tfront.a\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"colorhalftone","category":"color","author":"Evan Wallace","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"scale","type":"percent","initial-value":0.4,"interpolatable":true,"uniform":"scale"},{"id":"angle","type":"float","initial-value":15,"interpolatable":true,"uniform":"angle_deg"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Color halftone effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float scale;\r\nuniform mediump float angle_deg;\r\n\r\nmediump float pattern(mediump float angle, const mediump vec2 t)\r\n{\r\n\tmediump float s = sin(angle);\r\n\tmediump float c = cos(angle);\r\n\tmediump vec2 pt = vec2(c * t.x - s * t.y, s * t.x + c * t.y) * scale;\r\n\treturn sin(pt.x) * sin(pt.y) * 4.0;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float angle = angle_deg / 57.29578;\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump vec2 t = vTex * (1.0 / pixelSize) - vec2(0.5, 0.5);\r\n\t\r\n\tmediump vec3 cmy = 1.0 - front.rgb;\r\n\tmediump float k = min(cmy.x, min(cmy.y, cmy.z));\r\n\tcmy = (cmy - k) / (1.0 - k);\r\n\tcmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179, t), pattern(angle + 1.30899, t), pattern(angle, t)), 0.0, 1.0);\r\n\tk = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, t), 0.0, 1.0);\r\n\tgl_FragColor = vec4(1.0 - cmy - k, front.a);\r\n}\r\n","wgsl":"// Color halftone effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\n// Ported to WGSL from GLSL\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tscale : f32,\r\n\tangle_deg : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nfn pattern(angle : f32, t : vec2<f32>) -> f32\r\n{\r\n\tvar s : f32 = sin(angle);\r\n\tvar c : f32 = cos(angle);\r\n\tvar pt : vec2<f32> = vec2<f32>(c * t.x - s * t.y, s * t.x + c * t.y) * shaderParams.scale;\r\n\treturn sin(pt.x) * sin(pt.y) * 4.0;\r\n}\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar angle : f32 = shaderParams.angle_deg / 57.29578;\r\n\tvar t : vec2<f32> = input.fragUV * vec2<f32>(textureDimensions(textureFront)) - 0.5;\r\n\r\n\tvar cmy : vec3<f32> = vec3<f32>(1.0, 1.0, 1.0) - front.rgb;\r\n\tvar k : f32 = min(cmy.x, min(cmy.y, cmy.z));\r\n\tcmy = (cmy - k) / (1.0 - k);\r\n\tcmy = clamp(cmy * 10.0 - 3.0 + vec3<f32>(pattern(angle + 0.26179, t), pattern(angle + 1.30899, t), pattern(angle, t)), vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(1.0, 1.0, 1.0));\r\n\tk = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, t), 0.0, 1.0);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(vec3<f32>(1.0, 1.0, 1.0) - cmy - k, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"contrast","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"contrast","type":"percent","initial-value":1,"interpolatable":true,"uniform":"contrast"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Contrast effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float contrast;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= front.a;\r\n\t\r\n\tfront.rgb = (front.rgb - vec3(0.5)) * contrast + vec3(0.5);\r\n\t\r\n\tfront.rgb *= a;\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tcontrast : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t((front.rgb - vec3<f32>(0.5)) * shaderParams.contrast + vec3<f32>(0.5)) * front.a,\r\n\t\tfront.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"crosshatch","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"spacing","type":"percent","initial-value":0.03,"interpolatable":true,"uniform":"crosshatch_spacing"},{"id":"line-width","type":"percent","initial-value":0.003,"interpolatable":true,"uniform":"line_width"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Crosshatch effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform highmedp float crosshatch_spacing;\r\nuniform highmedp float line_width;\r\n\r\nvoid main(void)\r\n{\r\n\thighmedp vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\thighmedp float lum = dot(front.rgb, vec3(0.2125, 0.7154, 0.0721));\r\n     \r\n\tlowp vec3 colorToDisplay = vec3(1.0, 1.0, 1.0);\r\n\t\r\n\tif (lum < 1.00) \r\n\t{\r\n\t\tif (mod(tex.x + tex.y, crosshatch_spacing) <= line_width) \r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.75) \r\n\t{\r\n\t\tif (mod(tex.x - tex.y, crosshatch_spacing) <= line_width) \r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.50) \r\n\t{\r\n\t\tif (mod(tex.x + tex.y - (crosshatch_spacing / 2.0), crosshatch_spacing) <= line_width) \r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.3) \r\n\t{\r\n\t\tif (mod(tex.x - tex.y - (crosshatch_spacing / 2.0), crosshatch_spacing) <= line_width) \r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\r\n\tgl_FragColor = vec4(colorToDisplay * front.a, front.a);\r\n}\r\n","wgsl":"// Crosshatch effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tcrosshatch_spacing : f32,\r\n\tline_width : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar lum : f32 = dot(front.rgb, vec3<f32>(0.2125, 0.7154, 0.0721));\r\n\r\n\tvar colorToDisplay : vec3<f32> = vec3<f32>(1.0, 1.0, 1.0);\r\n\tvar crosshatch_spacing : f32 = shaderParams.crosshatch_spacing;\r\n\tvar line_width : f32 = shaderParams.line_width;\r\n\r\n\tif (lum < 1.0)\r\n\t{\r\n\t\tif (c3_mod(tex.x + tex.y, crosshatch_spacing) <= line_width)\r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3<f32>(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.75)\r\n\t{\r\n\t\tif (c3_mod(tex.x - tex.y, crosshatch_spacing) <= line_width)\r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3<f32>(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.5)\r\n\t{\r\n\t\tif (c3_mod(tex.x + tex.y - (crosshatch_spacing / 2.0), crosshatch_spacing) <= line_width)\r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3<f32>(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\tif (lum < 0.3)\r\n\t{\r\n\t\tif (c3_mod(tex.x - tex.y - (crosshatch_spacing / 2.0), crosshatch_spacing) <= line_width)\r\n\t\t{\r\n\t\t\tcolorToDisplay = vec3<f32>(0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(colorToDisplay * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"crystalball","category":"distortion","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"radius","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"radius"},{"id":"refractive-index","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"refractiveIndex"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Crystal Ball effect\r\n// Based on the glass sphere filter from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform mediump vec2 layoutStart;\r\nuniform mediump vec2 layoutEnd;\r\n\r\nconst highmedp vec3 lightPosition = vec3(-0.5, 0.5, 1.0);\r\nconst highmedp vec3 ambientLightPosition = vec3(0.0, 0.0, 1.0);\r\nuniform highmedp float radius;\r\nuniform highmedp float refractiveIndex;\r\n\r\nvoid main(void)\r\n{\r\n\thighmedp vec2 center = vec2(0.5, 0.5);\r\n\thighmedp vec2 srcSize = srcEnd - srcStart;\r\n\thighmedp vec2 layoutSize = layoutEnd - layoutStart;\r\n\thighmedp float aspectRatio = layoutSize.y / layoutSize.x;\r\n \r\n\thighmedp vec2 tex = (vTex - srcStart) / srcSize;\r\n\thighmedp vec2 otherTex = vec2(tex.x, (tex.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\thighmedp float distanceFromCenter = distance(center, otherTex);\r\n\tlowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\r\n\r\n\tdistanceFromCenter = distanceFromCenter / radius;\r\n\r\n\thighmedp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\r\n\thighmedp vec3 sphereNormal = normalize(vec3(otherTex - center, normalizedDepth));\r\n\r\n\thighmedp vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\r\n\thighmedp vec2 sampleTex = vec2(-refractedVector.x, refractedVector.y);\r\n\tsampleTex = (sampleTex + 1.0) * 0.5;\r\n\tsampleTex = clamp(sampleTex, 0.0, 1.0);\r\n\tsampleTex = sampleTex * srcSize + srcStart;\r\n\thighmedp vec4 front = texture2D(samplerFront, sampleTex);\r\n\thighmedp vec3 finalSphereColor = front.rgb;\r\n\r\n\t// Grazing angle lighting\r\n\thighmedp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\r\n\tfinalSphereColor += lightingIntensity;\r\n\r\n\t// Specular lighting\r\n\tlightingIntensity  = clamp(dot(normalize(lightPosition), sphereNormal), 0.0, 1.0);\r\n\tlightingIntensity  = pow(lightingIntensity, 15.0);\r\n\tfinalSphereColor += vec3(0.8, 0.8, 0.8) * lightingIntensity;\r\n\r\n\tgl_FragColor = vec4(finalSphereColor, front.a) * checkForPresenceWithinSphere;\r\n}\r\n","wgsl":"// Crystal Ball effect\r\n// Based on the glass sphere filter from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tradius : f32,\r\n\trefractiveIndex : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet center : vec2<f32> = vec2<f32>(0.5, 0.5);\r\nlet lightPosition : vec3<f32> = vec3<f32>(-0.5, -0.5, 1.0);\r\nlet ambientLightPosition : vec3<f32> = vec3<f32>(0.0, 0.0, 1.0);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar layoutSize : vec2<f32> = c3Params.layoutEnd - c3Params.layoutStart;\r\n\tvar aspectRatio : f32 = layoutSize.y / layoutSize.x;\r\n\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar otherTex : vec2<f32> = vec2<f32>(tex.x, (tex.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tvar distanceFromCenter : f32 = distance(center, otherTex);\r\n\tvar checkForPresenceWithinSphere : f32 = step(distanceFromCenter, shaderParams.radius);\r\n\r\n\tdistanceFromCenter = distanceFromCenter / shaderParams.radius;\r\n\r\n\tvar normalizedDepth : f32 = shaderParams.radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\r\n\tvar sphereNormal : vec3<f32> = normalize(vec3<f32>(otherTex - center, normalizedDepth));\r\n\r\n\tvar refractedVector : vec3<f32> = 2.0 * refract(vec3<f32>(0.0, 0.0, -1.0), sphereNormal, shaderParams.refractiveIndex);\r\n\tvar sampleTex : vec2<f32> = -refractedVector.xy;\r\n\tsampleTex = (sampleTex + 1.0) * 0.5;\r\n\tsampleTex = c3_clamp2(sampleTex, 0.0, 1.0);\r\n\tsampleTex = c3_normToSrc(sampleTex);\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, sampleTex);\r\n\tvar finalSphereColor : vec3<f32> = front.rgb;\r\n\r\n\t// Grazing angle lighting\r\n\tvar lightingIntensity : f32 = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\r\n\tfinalSphereColor = finalSphereColor + lightingIntensity;\r\n\r\n\t// Specular lighting\r\n\tlightingIntensity = clamp(dot(normalize(lightPosition), sphereNormal), 0.0, 1.0);\r\n\tlightingIntensity = pow(lightingIntensity, 15.0);\r\n\tfinalSphereColor = finalSphereColor + vec3<f32>(0.8) * lightingIntensity;\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(finalSphereColor, front.a) * checkForPresenceWithinSphere;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"darken","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Darken effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\t// Darken blend and premultiply\r\n\tfront.rgb = min(front.rgb, back.rgb) * front.a;\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Darken blend and premultiply\r\n\t\tmin(front.rgb, back.rgb) * front.a,\r\n\t\tfront.a\t\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"depthstripe","category":"3d","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"uses-depth":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"color1","type":"color","initial-value":[1,0,0],"interpolatable":true,"uniform":"color1"},{"id":"opacity1","type":"percent","initial-value":0.25,"interpolatable":true,"uniform":"opacity1"},{"id":"color2","type":"color","initial-value":[0,1,0],"interpolatable":true,"uniform":"color2"},{"id":"opacity2","type":"percent","initial-value":0.25,"interpolatable":true,"uniform":"opacity2"},{"id":"stripe-depth","type":"float","initial-value":10,"interpolatable":true,"uniform":"stripeDepth"},{"id":"offset","type":"float","initial-value":0,"interpolatable":true,"uniform":"stripeOffset"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Fog effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerDepth;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform lowp vec3 color1;\r\nuniform lowp float opacity1;\r\nuniform lowp vec3 color2;\r\nuniform lowp float opacity2;\r\nuniform mediump float stripeDepth;\r\nuniform mediump float stripeOffset;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float zFar = 10000.0;\r\n\tmediump float zNear = 1.0;\r\n\r\n\t// Retrieve front pixel and depth\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tmediump float depthSample = texture2D(samplerDepth, mix(destStart, destEnd, tex)).r;\r\n\tmediump float zLinear = zNear * zFar / (zFar + depthSample * (zNear - zFar));\r\n\r\n\tlowp float which = mod(floor((zLinear + stripeOffset) / stripeDepth), 2.0);\r\n\tif (which == 0.0)\r\n\t{\r\n\t\tgl_FragColor = mix(front, vec4(color1 * front.a, front.a), opacity1);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tgl_FragColor = mix(front, vec4(color2 * front.a, front.a), opacity2);\r\n\t}\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERDEPTH_BINDING%% var samplerDepth : sampler;\r\n%%TEXTUREDEPTH_BINDING%% var textureDepth : texture_depth_2d;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tcolor1 : vec3<f32>,\r\n\topacity1 : f32,\r\n\tcolor2 : vec3<f32>,\r\n\topacity2 : f32,\r\n\tstripeDepth : f32,\r\n\tstripeOffset : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n// Maybe move these to C3Params uniforms some time\r\nlet zFar : f32 = 10000.0;\r\nlet zNear : f32 = 1.0;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front pixel and depth\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\tvar depthSample : f32 = textureSample(textureDepth, samplerDepth, c3_getDepthUV(input.fragPos.xy, textureDepth));\r\n\tdepthSample = (depthSample + 1.0) / 2.0;\t\t// map [-1, 1] to [0, 1] - not sure why needed\r\n\tvar zLinear : f32 = zNear * zFar / (zFar + depthSample * (zNear - zFar));\r\n\r\n\tvar which : f32 = floor((zLinear + shaderParams.stripeOffset) / shaderParams.stripeDepth) % 2.0;\r\n\tvar stripeColor : vec3<f32> = select(shaderParams.color2, shaderParams.color1, which == 0.0);\r\n\tvar stripeOpacity : f32 = select(shaderParams.opacity2, shaderParams.opacity1, which == 0.0);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, vec4<f32>(stripeColor * front.a, front.a), stripeOpacity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"difference","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Difference effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels unpremultiplied\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\t// Difference blend and premultiply\r\n\tfront.rgb = (max(front.rgb, back.rgb) - min(front.rgb, back.rgb)) * front.a;\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Difference blend and premultiply\r\n\t\t(max(front.rgb, back.rgb) - min(front.rgb, back.rgb)) * front.a,\r\n\t\tfront.a\t\r\n\t);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"divide","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Divide effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\t// Divide back by front and premultiply\r\n    front.rgb = min(back.rgb / front.rgb, vec3(1.0, 1.0, 1.0)) * front.a;\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Divide back by front and premultiply\r\n\t\tmin(back.rgb / front.rgb, vec3<f32>(1.0)) * front.a,\r\n\t\tfront.a\t\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"dodge","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Dodge effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tfront.rgb = (back.rgb * front.a) / (1.0 - front.rgb);\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Dodge blend\r\n\t\t(back.rgb * front.a) / (vec3<f32>(1.0) - front.rgb),\r\n\t\tfront.a\t\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"dotscreen","category":"color","author":"Evan Wallace","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"scale","type":"percent","initial-value":1,"interpolatable":true,"uniform":"scale"},{"id":"angle","type":"float","initial-value":15,"interpolatable":true,"uniform":"angle_deg"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Dot screen effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float scale;\r\nuniform mediump float angle_deg;\r\n\r\nmediump float pattern()\r\n{\r\n\tmediump float angle = angle_deg / 57.29578;\r\n\tmediump float s = sin(angle);\r\n\tmediump float c = cos(angle);\r\n\tmediump vec2 tex = vTex * (1.0 / pixelSize) - vec2(0.5, 0.5);\r\n\tmediump vec2 pt = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * scale;\r\n\treturn sin(pt.x) * sin(pt.y) * 4.0;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float average = front.r / 3.0 + front.g / 3.0 + front.b / 3.0;\r\n\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), front.a);\r\n}\r\n","wgsl":"// Dot screen effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tscale : f32,\r\n\tangle_deg : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nfn pattern(fragUV : vec2<f32>) -> f32\r\n{\r\n\tvar angle : f32 = shaderParams.angle_deg / 57.29578;\r\n\tvar s : f32 = sin(angle);\r\n\tvar c : f32 = cos(angle);\r\n\tvar tex : vec2<f32> = fragUV * vec2<f32>(textureDimensions(textureFront)) - vec2<f32>(0.5, 0.5);\r\n\tvar pt : vec2<f32> = vec2<f32>(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * shaderParams.scale;\r\n\treturn sin(pt.x) * sin(pt.y) * 4.0;\r\n}\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar average : f32 = (front.r + front.g + front.b) / 3.0;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(vec3<f32>(average * 10.0 - 5.0 + pattern(input.fragUV)), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"emboss","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Emboss effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float intensity;\r\nuniform mediump vec2 pixelSize;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tlowp vec3 color = vec3(0.5);\r\n\tcolor -= texture2D(samplerFront, vTex - pixelSize).rgb * 2.0;\r\n    color += texture2D(samplerFront, vTex + pixelSize).rgb * 2.0;\r\n\tcolor = vec3(color.r * 0.299 + color.g * 0.587 + color.b * 0.114);\r\n\t\r\n\tgl_FragColor = mix(front, vec4(color * front.a, front.a), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\t\r\n\tvar color : vec3<f32> = vec3<f32>(0.5)\r\n\t\t- textureSample(textureFront, samplerFront, input.fragUV - pixelSize).rgb * 2.0\r\n\t\t+ textureSample(textureFront, samplerFront, input.fragUV + pixelSize).rgb * 2.0;\r\n\tcolor = vec3<f32>(c3_grayscale(color));\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, vec4<f32>(color * front.a, front.a), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"exclusion","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Exclusion effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Exclusion blend\r\n    front.rgb = 1.0 - (((1.0 - back.rgb * front.a) * (1.0 - front.rgb)) + (back.rgb * front.a * front.rgb));\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t1.0 - (((1.0 - back.rgb * front.a) * (1.0 - front.rgb)) + (back.rgb * front.a * front.rgb)),\r\n\t\tfront.a\r\n\t);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"exposure","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"exposure","type":"percent","initial-value":0,"interpolatable":true,"uniform":"exposure"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Exposure effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump float exposure;\r\n\r\nvoid main(void)\r\n{\t\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tgl_FragColor = vec4(front.rgb * pow(2.0, exposure), front.a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\texposure : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(front.rgb * pow(2.0, shaderParams.exposure), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"fogexponential","category":"3d","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"uses-depth":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"fog-color","type":"color","initial-value":[1,1,1],"interpolatable":true,"uniform":"fogColor"},{"id":"fog-density","type":"percent","initial-value":0.02,"interpolatable":true,"uniform":"fogDensity"},{"id":"near-dist","type":"float","initial-value":10,"interpolatable":true,"uniform":"nearDist"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Fog effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerDepth;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform lowp vec3 fogColor;\r\nuniform mediump float fogDensity;\r\nuniform mediump float nearDist;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float zFar = 10000.0;\r\n\tmediump float zNear = 1.0;\r\n\tmediump float log2 = 1.442695;\r\n\r\n\t// Retrieve front pixel and depth\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tmediump float depthSample = texture2D(samplerDepth, mix(destStart, destEnd, tex)).r;\r\n\tmediump float zLinear = zNear * zFar / (zFar + depthSample * (zNear - zFar));\r\n\r\n\tmediump float fogDist = max(zLinear - nearDist, 0.0);\r\n\tmediump float fogAmount = clamp(1.0 - exp2(-fogDensity * fogDensity * fogDist * fogDist * log2), 0.0, 1.0);\r\n\t\r\n\tgl_FragColor = mix(front, vec4(fogColor * front.a, front.a), fogAmount);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERDEPTH_BINDING%% var samplerDepth : sampler;\r\n%%TEXTUREDEPTH_BINDING%% var textureDepth : texture_depth_2d;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfogColor : vec3<f32>,\r\n\tfogDensity : f32,\r\n\tnearDist : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n// Maybe move these to C3Params uniforms some time\r\nlet zFar : f32 = 10000.0;\r\nlet zNear : f32 = 1.0;\r\n\r\nlet log_2 = 1.442695;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front pixel and depth\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\tvar depthSample : f32 = textureSample(textureDepth, samplerDepth, c3_getDepthUV(input.fragPos.xy, textureDepth));\r\n\tdepthSample = (depthSample + 1.0) / 2.0;\t\t// map [-1, 1] to [0, 1] - not sure why needed\r\n\tvar zLinear : f32 = zNear * zFar / (zFar + depthSample * (zNear - zFar));\r\n\r\n\tvar fogDist = max(zLinear - shaderParams.nearDist, 0.0);\r\n\tvar fogAmount : f32 = clamp(1.0 - exp2(-shaderParams.fogDensity * shaderParams.fogDensity * fogDist * fogDist * log_2), 0.0, 1.0);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, vec4<f32>(shaderParams.fogColor * front.a, front.a), fogAmount);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"gamma","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"gamma","type":"float","initial-value":1,"interpolatable":true,"uniform":"gamma"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Gamma effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump float gamma;\r\n\r\nvoid main(void)\r\n{\t\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tgl_FragColor = vec4(pow(front.rgb, vec3(gamma)), front.a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tgamma : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(pow(front.rgb, vec3<f32>(shaderParams.gamma)), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"glass","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"density","type":"percent","initial-value":2,"interpolatable":true,"uniform":"magnification"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Glass effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float magnification;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\t// Glass distort\r\n\tmediump float src = front.r * 0.299 + front.g * 0.587 + front.b * 0.114;\r\n\t\r\n\tmediump vec3 front2 = texture2D(samplerFront, vTex + vec2(pixelSize.x, 0.0)).rgb;\r\n\tmediump vec3 front3 = texture2D(samplerFront, vTex + vec2(0.0, pixelSize.y)).rgb;\r\n\t\r\n\tmediump vec2 diff = vec2(src - (front2.r * 0.299 + front2.g * 0.587 + front2.b * 0.114),\r\n\t\t\t\t\t\t\t src - (front3.r * 0.299 + front3.g * 0.587 + front3.b * 0.114));\r\n\t\r\n\tmediump vec2 p = tex + diff * pixelSize * magnification * 64.0 * front.a;\r\n\t\r\n\tgl_FragColor = texture2D(samplerBack, mix(destStart, destEnd, p));\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tmagnification : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\t\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\t\r\n\t// Glass distort\r\n\tvar src : f32 = c3_grayscale(front.rgb);\r\n\t\r\n\tvar front2 : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelSize.x, 0.0)).rgb;\r\n\tvar front3 : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelSize.y)).rgb;\r\n\t\r\n\tvar diff : vec2<f32> = vec2<f32>(\r\n\t\tsrc - c3_grayscale(front2.rgb),\r\n\t\tsrc - c3_grayscale(front3.rgb)\r\n\t);\r\n\t\r\n\tvar p : vec2<f32> = tex + diff * pixelSize * shaderParams.magnification * 64.0 * front.a;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, mix(c3Params.destStart, c3Params.destEnd, p));\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"glowhorizontal","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":8,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Glow horizontal effect\r\nvarying mediump vec2 vTex;\r\nuniform mediump sampler2D samplerFront;\r\n\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec4 sum = vec4(0.0);\r\n\tmediump float pixelWidth = pixelSize.x;\r\n\tmediump float halfPixelWidth = pixelWidth / 2.0;\r\n\t\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tsum += front * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\r\n\t\r\n\tgl_FragColor = mix(front, max(front, sum), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelWidth : f32 = c3_getPixelSize(textureFront).x;\r\n\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tvar sum : vec4<f32> =\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\r\n\t\tfront * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 1.5, 0.0)) * 0.16 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 3.5, 0.0)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 5.5, 0.0)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelWidth * 7.5, 0.0)) * 0.06;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, max(front, sum), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"glowvertical","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":8},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Glow vertical effect\r\nvarying mediump vec2 vTex;\r\nuniform mediump sampler2D samplerFront;\r\n\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec4 sum = vec4(0.0);\r\n\tmediump float pixelHeight = pixelSize.y;\r\n\tmediump float halfPixelHeight = pixelHeight / 2.0;\r\n\t\r\n\t// Add nine horizontal samples, with mid-pixel sampling to get two pixels in one\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tsum += front * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\r\n\tsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\r\n\t\r\n\tgl_FragColor = mix(front, max(front, sum), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelHeight : f32 = c3_getPixelSize(textureFront).y;\r\n\t\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\t// Add nine vertical samples, with mid-pixel sampling to get two pixels in one\r\n\tvar sum : vec4<f32> =\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\r\n\t\tfront * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 1.5)) * 0.16 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 3.5)) * 0.13 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 5.5)) * 0.10 +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelHeight * 7.5)) * 0.06;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, max(front, sum), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"grayscale","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Grayscale effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\t// Calculate grayscale amount\r\n\tlowp float gray = front.r * 0.299 + front.g * 0.587 + front.b * 0.114;\r\n\t\r\n\t// Output a gray pixel with source alpha\r\n\tgl_FragColor = mix(front, vec4(gray, gray, gray, front.a), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar gray : f32 = c3_grayscale(front.rgb);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, vec4<f32>(gray, gray, gray, front.a), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"grayscalemask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Grayscale mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Calculate grayscale amount\r\n\tlowp float gray = back.r * 0.299 + back.g * 0.587 + back.b * 0.114;\r\n\t\r\n\t// Output a gray pixel with source alpha\r\n\tgl_FragColor = mix(back, vec4(gray, gray, gray, back.a), fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\t\r\n\tvar gray : f32 = c3_grayscale(back.rgb);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back, vec4<f32>(gray, gray, gray, back.a), fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hardlight","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Hard light effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tif (front.r * 0.299 + front.g * 0.587 + front.b * 0.114 <= 0.5)\r\n\t{\r\n\t\t// Multiply\r\n\t\tfront *= back * 2.0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Screen blend\r\n\t\tfront.rgb = 1.0 - ((1.0 - (2.0 * front.rgb - 1.0)) * (1.0 - back.rgb * front.a));\r\n\t}\r\n\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = select(\r\n\t\t// Screen blend\r\n\t\tvec4<f32>(\r\n\t\t\t1.0 - ((1.0 - (2.0 * front.rgb - 1.0)) * (1.0 - back.rgb * front.a)),\r\n\t\t\tfront.a\r\n\t\t),\r\n\t\t// Multiply\r\n\t\tfront * back * 2.0,\r\n\t\t\r\n\t\t// Condition\r\n\t\tc3_grayscale(front.rgb) <= 0.5\r\n\t);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hexpixellate","category":"color","author":"Evan Wallace","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"scale","type":"float","initial-value":16,"interpolatable":true,"uniform":"scale"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Hexagonal pixellate effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nprecision mediump float;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float scale;\r\n\r\nvoid main()\r\n{\r\n\tvec2 texSize = 1.0 / pixelSize;\r\n\tvec2 tex = (vTex * texSize - vec2(0.5, 0.5)) / scale;\r\n\ttex.y /= 0.866025404;\r\n\ttex.x -= tex.y * 0.5;\r\n\t\r\n\tvec2 a;\r\n\tif (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0)\r\n\t\ta = vec2(floor(tex.x), floor(tex.y));\r\n\telse\r\n\t\ta = vec2(ceil(tex.x), ceil(tex.y));\r\n\t\r\n\tvec2 b = vec2(ceil(tex.x), floor(tex.y));\r\n\tvec2 c = vec2(floor(tex.x), ceil(tex.y));\r\n\t\r\n\tvec3 tex2 = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\r\n\tvec3 a2 = vec3(a.x, a.y, 1.0 - a.x - a.y);\r\n\tvec3 b2 = vec3(b.x, b.y, 1.0 - b.x - b.y);\r\n\tvec3 c2 = vec3(c.x, c.y, 1.0 - c.x - c.y);\r\n\t\r\n\tfloat alen = length(tex2 - a2);\r\n\tfloat blen = length(tex2 - b2);\r\n\tfloat clen = length(tex2 - c2);\r\n\t\r\n\tvec2 choice;\r\n\tif (alen < blen)\r\n\t{\r\n\t\tif (alen < clen)\r\n\t\t\tchoice = a;\r\n\t\telse\r\n\t\t\tchoice = c;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (blen < clen)\r\n\t\t\tchoice = b;\r\n\t\telse\r\n\t\t\tchoice = c;\r\n\t}\r\n\t\r\n\tchoice.x += choice.y * 0.5;\r\n\tchoice.y *= 0.866025404;\r\n\tchoice *= scale / texSize;\r\n\tchoice += vec2(0.5, 0.5) / texSize;\r\n\tchoice = clamp(choice, min(srcStart, srcEnd), max(srcStart, srcEnd));\r\n\tgl_FragColor = texture2D(samplerFront, choice);\r\n}","wgsl":"// Hexagonal pixellate effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tscale : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar texSize : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\r\n\tvar tex : vec2<f32> = (input.fragUV * texSize - 0.5) / shaderParams.scale;\r\n\ttex.y = tex.y / 0.866025404;\r\n\ttex.x = tex.x - tex.y * 0.5;\r\n\t\r\n\tvar a : vec2<f32> = select(\r\n\t\tvec2<f32>(ceil(tex.x), ceil(tex.y)),\r\n\t\tvec2<f32>(floor(tex.x), floor(tex.y)),\r\n\t\ttex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0\r\n\t);\r\n\t\r\n\tvar b : vec2<f32> = vec2<f32>(ceil(tex.x), floor(tex.y));\r\n\tvar c : vec2<f32> = vec2<f32>(floor(tex.x), ceil(tex.y));\r\n\t\r\n\tvar tex2 : vec3<f32> = vec3<f32>(tex.x, tex.y, 1.0 - tex.x - tex.y);\r\n\tvar a2 : vec3<f32> = vec3<f32>(a.x, a.y, 1.0 - a.x - a.y);\r\n\tvar b2 : vec3<f32> = vec3<f32>(b.x, b.y, 1.0 - b.x - b.y);\r\n\tvar c2 : vec3<f32> = vec3<f32>(c.x, c.y, 1.0 - c.x - c.y);\r\n\t\r\n\tvar alen : f32 = length(tex2 - a2);\r\n\tvar blen : f32 = length(tex2 - b2);\r\n\tvar clen : f32 = length(tex2 - c2);\r\n\t\r\n\tvar choice : vec2<f32> = select(\r\n\t\tselect(c, b, blen < clen),\r\n\t\tselect(c, a, alen < clen),\r\n\t\talen < blen\r\n\t);\r\n\t\r\n\tchoice.x = choice.x + choice.y * 0.5;\r\n\tchoice.y = choice.y * 0.866025404;\r\n\tchoice = choice * shaderParams.scale / texSize;\r\n\tchoice = choice + vec2<f32>(0.5) / texSize;\r\n\tchoice = c3_clampToSrc(choice);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, choice);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hexpixellatemask","category":"mask","author":"Evan Wallace","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"scale","type":"float","initial-value":16,"interpolatable":true,"uniform":"scale"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Hexagonal pixellate mask effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nprecision mediump float;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float scale;\r\n\r\nvoid main()\r\n{\r\n\tfloat fronta = texture2D(samplerFront, vTex).a;\r\n\tvec2 texSize = 1.0 / pixelSize;\r\n\tvec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\ttex = (mix(destStart, destEnd, tex) * texSize - vec2(0.5, 0.5)) / scale;\r\n\ttex.y /= 0.866025404;\r\n\ttex.x -= tex.y * 0.5;\r\n\t\r\n\tvec2 a;\r\n\tif (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0)\r\n\t\ta = vec2(floor(tex.x), floor(tex.y));\r\n\telse\r\n\t\ta = vec2(ceil(tex.x), ceil(tex.y));\r\n\t\r\n\tvec2 b = vec2(ceil(tex.x), floor(tex.y));\r\n\tvec2 c = vec2(floor(tex.x), ceil(tex.y));\r\n\t\r\n\tvec3 tex2 = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\r\n\tvec3 a2 = vec3(a.x, a.y, 1.0 - a.x - a.y);\r\n\tvec3 b2 = vec3(b.x, b.y, 1.0 - b.x - b.y);\r\n\tvec3 c2 = vec3(c.x, c.y, 1.0 - c.x - c.y);\r\n\t\r\n\tfloat alen = length(tex2 - a2);\r\n\tfloat blen = length(tex2 - b2);\r\n\tfloat clen = length(tex2 - c2);\r\n\t\r\n\tvec2 choice;\r\n\tif (alen < blen)\r\n\t{\r\n\t\tif (alen < clen)\r\n\t\t\tchoice = a;\r\n\t\telse\r\n\t\t\tchoice = c;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (blen < clen)\r\n\t\t\tchoice = b;\r\n\t\telse\r\n\t\t\tchoice = c;\r\n\t}\r\n\t\r\n\tchoice.x += choice.y * 0.5;\r\n\tchoice.y *= 0.866025404;\r\n\tchoice *= scale / texSize;\r\n\tchoice += vec2(0.5, 0.5) / texSize;\r\n\tchoice = clamp(choice, min(destStart, destEnd), max(destStart, destEnd));\r\n\tgl_FragColor = texture2D(samplerBack, choice) * fronta;\r\n}","wgsl":"// Radial pixellate effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tscale : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\t\r\n\tvar texSize : vec2<f32> = vec2<f32>(textureDimensions(textureBack));\r\n\tvar tex : vec2<f32> = c3_getBackUV(input.fragPos.xy, textureBack);\r\n\ttex = (tex * texSize - vec2<f32>(0.5)) / shaderParams.scale;\r\n\ttex.y = tex.y / 0.866025404;\r\n\ttex.x = tex.x - tex.y * 0.5;\r\n\t\r\n\tvar a : vec2<f32> = select(\r\n\t\tvec2<f32>(ceil(tex.x), ceil(tex.y)),\r\n\t\tvec2<f32>(floor(tex.x), floor(tex.y)),\r\n\t\ttex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0\r\n\t);\r\n\t\r\n\tvar b : vec2<f32> = vec2<f32>(ceil(tex.x), floor(tex.y));\r\n\tvar c : vec2<f32> = vec2<f32>(floor(tex.x), ceil(tex.y));\r\n\t\r\n\tvar tex2 : vec3<f32> = vec3<f32>(tex.x, tex.y, 1.0 - tex.x - tex.y);\r\n\tvar a2 : vec3<f32> = vec3<f32>(a.x, a.y, 1.0 - a.x - a.y);\r\n\tvar b2 : vec3<f32> = vec3<f32>(b.x, b.y, 1.0 - b.x - b.y);\r\n\tvar c2 : vec3<f32> = vec3<f32>(c.x, c.y, 1.0 - c.x - c.y);\r\n\t\r\n\tvar alen : f32 = length(tex2 - a2);\r\n\tvar blen : f32 = length(tex2 - b2);\r\n\tvar clen : f32 = length(tex2 - c2);\r\n\t\r\n\tvar choice : vec2<f32> = select(\r\n\t\tselect(c, b, blen < clen),\r\n\t\tselect(c, a, alen < clen),\r\n\t\talen < blen\r\n\t);\r\n\t\r\n\tchoice.x = choice.x + choice.y * 0.5;\r\n\tchoice.y = choice.y * 0.866025404;\r\n\tchoice = choice * shaderParams.scale / texSize;\r\n\tchoice = choice + vec2<f32>(0.5) / texSize;\r\n\tchoice = c3_clampToDest(choice);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, choice) * fronta;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"highlightshadow","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"shadow-factor","type":"percent","initial-value":0,"interpolatable":true,"uniform":"shadows"},{"id":"highlight-factor","type":"percent","initial-value":1,"interpolatable":true,"uniform":"highlights"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Highlight shadows effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nuniform lowp float shadows;\r\nuniform lowp float highlights;\r\n\r\nconst mediump vec3 luminanceWeighting = vec3(0.3, 0.3, 0.3);\r\n\r\nvoid main(void)\r\n{\t\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump float luminance = dot(front.rgb, luminanceWeighting);\r\n\r\n\tmediump float shadow = clamp((pow(luminance, 1.0 / (shadows + 1.0)) + (-0.76) * pow(luminance, 2.0 / (shadows + 1.0))) - luminance, 0.0, 1.0);\r\n\tmediump float highlight = clamp((1.0 - (pow(1.0 - luminance, 1.0 / (2.0 - highlights)) + (-0.8) * pow(1.0 - luminance, 2.0 / (2.0 - highlights)))) - luminance, -1.0, 0.0);\r\n\tlowp vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((front.rgb - vec3(0.0, 0.0, 0.0)) / (luminance - 0.0));\r\n\r\n\tgl_FragColor = vec4(result.rgb, front.a);\r\n}\r\n","wgsl":"// Highlight shadows effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tshadows : f32,\r\n\thighlights : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet luminanceWeighting : vec3<f32> = vec3<f32>(0.3, 0.3, 0.3);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar luminance : f32 = dot(front.rgb, luminanceWeighting);\r\n\t\r\n\tvar shadow : f32 = clamp((pow(luminance, 1.0 / (shaderParams.shadows + 1.0)) + (-0.76) * pow(luminance, 2.0 / (shaderParams.shadows + 1.0))) - luminance, 0.0, 1.0);\r\n\tvar highlight : f32 = clamp((1.0 - (pow(1.0 - luminance, 1.0 / (2.0 - shaderParams.highlights)) + (-0.8) * pow(1.0 - luminance, 2.0 / (2.0 - shaderParams.highlights)))) - luminance, -1.0, 0.0);\r\n\tvar result : vec3<f32> = vec3<f32>(0.0) + (luminance + shadow + highlight) * (front.rgb / luminance);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(result, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hsladjust","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"hue","type":"percent","initial-value":0,"interpolatable":true,"uniform":"huerotate"},{"id":"saturation","type":"percent","initial-value":1,"interpolatable":true,"uniform":"satadjust"},{"id":"luminosity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"lumadjust"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Adjust HSL effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nprecision mediump float;\r\nuniform float huerotate;\r\nuniform float satadjust;\r\nuniform float lumadjust;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\r\n\t// NOTE: to avoid weird artefacts (possibly floating point precision related?) in some cases when combining with alpha,\r\n\t// ensure the huerotate parameter is normalised to a [-0.5,0.5] range instead of [0, 1].\r\n\tvec3 rgb = rgb_to_hsl(front.rgb) + vec3((huerotate > 0.5 ? huerotate - 1.0 : huerotate), 0, (lumadjust - 1.0) * front.a);\r\n\trgb.y *= satadjust;\r\n\trgb = hsl_to_rgb(rgb);\r\n\tgl_FragColor = vec4(rgb, front.a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\thuerotate : f32,\r\n\tsatadjust : f32,\r\n\tlumadjust : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\t// NOTE: to avoid weird artefacts (possibly floating point precision related?) in some cases when combining with alpha,\r\n\t// ensure the huerotate parameter is normalised to a [-0.5,0.5] range instead of [0, 1].\r\n\tvar huerotate : f32 = shaderParams.huerotate;\r\n\tif (huerotate > 0.5)\r\n\t{\r\n\t\thuerotate = huerotate - 1.0;\r\n\t}\r\n\t\r\n\tvar rgb : vec3<f32> = c3_RGBtoHSL(front.rgb) + vec3<f32>(huerotate, 0.0, (shaderParams.lumadjust - 1.0) * front.a);\r\n\trgb.y = rgb.y * shaderParams.satadjust;\r\n\trgb = c3_HSLtoRGB(rgb);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hsladjustmask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"hue","type":"percent","initial-value":0,"interpolatable":true,"uniform":"huerotate"},{"id":"saturation","type":"percent","initial-value":1,"interpolatable":true,"uniform":"satadjust"},{"id":"luminosity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"lumadjust"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Adjust HSL mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nprecision mediump float;\r\nuniform float huerotate;\r\nuniform float satadjust;\r\nuniform float lumadjust;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// NOTE: to avoid weird artefacts (possibly floating point precision related?) in some cases when combining with alpha,\r\n\t// ensure the huerotate parameter is normalised to a [-0.5,0.5] range instead of [0, 1].\r\n\tvec3 rgb = rgb_to_hsl(back.rgb) + vec3((huerotate > 0.5 ? huerotate - 1.0 : huerotate), 0, (lumadjust - 1.0) * fronta);\r\n\r\n\trgb.y *= satadjust;\r\n\trgb = hsl_to_rgb(rgb);\r\n\tgl_FragColor = mix(back, vec4(rgb, back.a), fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\thuerotate : f32,\r\n\tsatadjust : f32,\r\n\tlumadjust : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\t\r\n\t// NOTE: to avoid weird artefacts (possibly floating point precision related?) in some cases when combining with alpha,\r\n\t// ensure the huerotate parameter is normalised to a [-0.5,0.5] range instead of [0, 1].\r\n\tvar huerotate : f32 = shaderParams.huerotate;\r\n\tif (huerotate > 0.5)\r\n\t{\r\n\t\thuerotate = huerotate - 1.0;\r\n\t}\r\n\t\r\n\tvar rgb : vec3<f32> = c3_RGBtoHSL(back.rgb) + vec3<f32>(huerotate, 0.0, (shaderParams.lumadjust - 1.0) * fronta);\r\n\trgb.y = rgb.y * shaderParams.satadjust;\r\n\trgb = c3_HSLtoRGB(rgb);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back, vec4<f32>(rgb, back.a), fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"hueblend","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Hue effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nprecision mediump float;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\tvec3 fronthsl = rgb_to_hsl(front.rgb / front.a);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tvec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tvec3 backhsl = rgb_to_hsl(back.rgb / back.a);\r\n\r\n\t// Use hue of front and saturation and luminosity of back\r\n\tfronthsl = hsl_to_rgb(vec3(fronthsl.x, backhsl.y, backhsl.z));\r\n\tfronthsl *= front.a;\r\n\r\n\tgl_FragColor = vec4(fronthsl.r, fronthsl.g, fronthsl.b, front.a) * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar fronthsl : vec3<f32> = c3_RGBtoHSL(front.rgb);\r\n\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\tvar backhsl : vec3<f32> = c3_RGBtoHSL(back.rgb);\r\n\r\n\t// Use hue of front and saturation and luminosity of back\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\tc3_HSLtoRGB(vec3<f32>(fronthsl.x, backhsl.y, backhsl.z)) * front.a,\r\n\t\tfront.a\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"inverse","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Inverse effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\t// Inverse the RGB components\r\n\tlowp vec3 inverse = vec3(front.a - front.rgb);\r\n\t\r\n\t// Output inverted pixel\r\n\tgl_FragColor = vec4(mix(front.rgb, inverse, intensity), front.a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar inverse : vec3<f32> = vec3<f32>(front.a) - front.rgb;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(mix(front.rgb, inverse, shaderParams.intensity), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"lens2","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":false,"must-predraw":true,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"magnification","type":"percent","initial-value":1,"interpolatable":true,"uniform":"magnification"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Lens effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform mediump float magnification;\r\n\r\nvoid main(void)\r\n{\t\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\t// Lens distort\r\n\tmediump float zoomFactor = (0.5 - (front.r * 0.299 + front.g * 0.587 + front.b * 0.114)) * front.a * magnification;\r\n\tmediump vec2 center = (srcOriginStart + srcOriginEnd) / 2.0;\r\n\t\r\n\tmediump vec2 p = tex;\r\n\tp += (tex - center) * zoomFactor;\r\n\r\n\tgl_FragColor = texture2D(samplerBack, mix(destStart, destEnd, p));\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tmagnification : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\t\r\n\t// Lens distort\r\n\tvar zoomFactor : f32 = (0.5 - c3_grayscale(front.rgb)) * front.a * shaderParams.magnification;\r\n\tvar center : vec2<f32> = (c3Params.srcOriginStart + c3Params.srcOriginEnd) / 2.0;\r\n\t\r\n\tvar p : vec2<f32> = tex + (tex - center) * zoomFactor;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, mix(c3Params.destStart, c3Params.destEnd, p));\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"lighten","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Lighten effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels unpremultiplied\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\t// Lighten blend and premultiply\r\n\tfront.rgb = max(front.rgb, back.rgb) * front.a;\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Lighten blend and premultiply\r\n\t\tmax(front.rgb, back.rgb) * front.a,\r\n\t\tfront.a\t\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"lumblend","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Luminosity effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nprecision mediump float;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\tvec3 fronthsl = rgb_to_hsl(front.rgb / front.a);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tvec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tvec3 backhsl = rgb_to_hsl(back.rgb / back.a);\r\n\r\n\t// Use luminosity of front and hue and saturation of back\r\n\tfronthsl = hsl_to_rgb(vec3(backhsl.x, backhsl.y, fronthsl.z));\r\n\tfronthsl *= front.a;\r\n\r\n\tgl_FragColor = vec4(fronthsl.r, fronthsl.g, fronthsl.b, front.a) * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar fronthsl : vec3<f32> = c3_RGBtoHSL(front.rgb);\r\n\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\tvar backhsl : vec3<f32> = c3_RGBtoHSL(back.rgb);\r\n\r\n\t// Use luminosity of front and hue and saturation of back\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\tc3_HSLtoRGB(vec3<f32>(backhsl.x, backhsl.y, fronthsl.z)) * front.a,\r\n\t\tfront.a\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"multiply","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Multiply effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Multiply front and back\r\n    front *= back;\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = front * back;\t\t// multiply front and back\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"noise","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":true,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":0.4,"interpolatable":true,"uniform":"intensity"},{"id":"color","type":"percent","initial-value":1,"interpolatable":true,"uniform":"noiseColor"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Noise effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform highmedp float seconds;\r\nuniform lowp float intensity;\r\nuniform lowp float noiseColor;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= a;\r\n\t\r\n\thighmedp float seconds_mod = mod(seconds, 10.0);\r\n\t\r\n\t// Add pseudorandom noise then premultiply\r\n\tmediump vec3 noise = vec3(fract(sin(dot(vTex.xy, vec2(12.9898,78.233)) + seconds_mod) * 43758.5453),\r\n\t\t\t\t\t\t\t  fract(sin(dot(vTex.yx, vec2(12.9898,-78.233)) + seconds_mod) * 43758.5453),\r\n\t\t\t\t\t\t\t  fract(sin(dot(vTex.xy, vec2(-12.9898,-78.233)) + seconds_mod) * 43758.5453));\r\n\tnoise = mix(vec3(noise.r), noise, noiseColor);\r\n\tfront.rgb += (noise * intensity) - (intensity / 2.0);\r\n\tfront.rgb *= a;\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32,\r\n\tnoiseColor : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar seconds_mod : f32 = c3Params.seconds % 10.0;\r\n\t\r\n\tvar noise : vec3<f32> = vec3<f32>(\r\n\t\tfract(sin(dot(input.fragUV.xy, vec2<f32>(12.9898,78.233)) + seconds_mod) * 43758.5453),\r\n\t\tfract(sin(dot(input.fragUV.yx, vec2<f32>(12.9898,-78.233)) + seconds_mod) * 43758.5453),\r\n\t\tfract(sin(dot(input.fragUV.xy, vec2<f32>(-12.9898,-78.233)) + seconds_mod) * 43758.5453));\r\n\tnoise = mix(vec3<f32>(noise.r), noise, shaderParams.noiseColor);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>((front.rgb + ((noise * shaderParams.intensity) - (shaderParams.intensity / 2.0))) * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"noisemask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":0.4,"interpolatable":true,"uniform":"intensity"},{"id":"color","type":"percent","initial-value":1,"interpolatable":true,"uniform":"noiseColor"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Noise effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform highmedp float seconds;\r\nuniform lowp float intensity;\r\nuniform lowp float noiseColor;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back1 = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tlowp vec4 back2 = back1;\r\n\tback2.rgb /= back2.a;\r\n\t\r\n\thighmedp float seconds_mod = mod(seconds, 10.0);\r\n\t\r\n\t// Add pseudorandom noise then premultiply\r\n\tmediump vec3 noise = vec3(fract(sin(dot(vTex.xy, vec2(12.9898,78.233)) + seconds_mod) * 43758.5453),\r\n\t\t\t\t\t\t\t  fract(sin(dot(vTex.yx, vec2(12.9898,-78.233)) + seconds_mod) * 43758.5453),\r\n\t\t\t\t\t\t\t  fract(sin(dot(vTex.xy, vec2(-12.9898,-78.233)) + seconds_mod) * 43758.5453));\r\n\tnoise = mix(vec3(noise.r), noise, noiseColor);\r\n\tback2.rgb += (noise * intensity) - (intensity / 2.0);\r\n\tback2.rgb *= back2.a;\r\n\t\r\n\tgl_FragColor = mix(back1, back2, fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32,\r\n\tnoiseColor : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\r\n\tvar back1 : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\tvar back2 : vec4<f32> = c3_unpremultiply(back1);\r\n\t\r\n\t// Add pseudorandom noise\r\n\tvar seconds_mod : f32 = c3Params.seconds % 10.0;\r\n\r\n\tvar noise : vec3<f32> = vec3<f32>(\r\n\t\tfract(sin(dot(input.fragUV.xy, vec2<f32>(12.9898,78.233)) + seconds_mod) * 43758.5453),\r\n\t\tfract(sin(dot(input.fragUV.yx, vec2<f32>(12.9898,-78.233)) + seconds_mod) * 43758.5453),\r\n\t\tfract(sin(dot(input.fragUV.xy, vec2<f32>(-12.9898,-78.233)) + seconds_mod) * 43758.5453));\r\n\tnoise = mix(vec3<f32>(noise.r), noise, shaderParams.noiseColor);\r\n\tback2 = vec4<f32>(back2.rgb + (noise * shaderParams.intensity) - (shaderParams.intensity / 2.0), back2.a);\r\n\tback2 = c3_premultiply(back2);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back1, back2, fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"oilpainting","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Oil painting effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nprecision highmedp float;\r\nuniform mediump vec2 pixelSize;\r\n \r\nvoid main (void)\r\n{\r\n\tconst int radius = 3;\r\n\tvec2 src_size = 1.0 / pixelSize;\r\n\t\r\n\tlowp float alpha = texture2D(samplerFront, vTex).a;\r\n    vec2 uv = vTex;\r\n    float n = float((radius + 1) * (radius + 1));\r\n    \r\n    vec3 m[4];\r\n    vec3 s[4];\r\n    for (int k = 0; k < 4; ++k) {\r\n        m[k] = vec3(0.0);\r\n        s[k] = vec3(0.0);\r\n    }\r\n    \r\n    for (int j = -radius; j <= 0; ++j)  {\r\n        for (int i = -radius; i <= 0; ++i)  {\r\n            vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;\r\n            m[0] += c;\r\n            s[0] += c * c;\r\n        }\r\n    }\r\n    \r\n    for (int j = -radius; j <= 0; ++j)  {\r\n        for (int i = 0; i <= radius; ++i)  {\r\n            vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;\r\n            m[1] += c;\r\n            s[1] += c * c;\r\n        }\r\n    }\r\n    \r\n    for (int j = 0; j <= radius; ++j)  {\r\n        for (int i = 0; i <= radius; ++i)  {\r\n            vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;\r\n            m[2] += c;\r\n            s[2] += c * c;\r\n        }\r\n    }\r\n    \r\n    for (int j = 0; j <= radius; ++j)  {\r\n        for (int i = -radius; i <= 0; ++i)  {\r\n            vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;\r\n            m[3] += c;\r\n            s[3] += c * c;\r\n        }\r\n    } \r\n    \r\n    float min_sigma2 = 1e+2;\r\n    for (int k = 0; k < 4; ++k) {\r\n        m[k] /= n;\r\n        s[k] = abs(s[k] / n - m[k] * m[k]);\r\n        \r\n        float sigma2 = s[k].r + s[k].g + s[k].b;\r\n        if (sigma2 < min_sigma2) {\r\n            min_sigma2 = sigma2;\r\n            gl_FragColor = vec4(m[k], alpha);\r\n        }\r\n    }\r\n }","wgsl":"// Oil painting effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tlet radius : i32 = 3;\r\n\tvar src_size : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\r\n\t\r\n\tvar alpha : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar uv : vec2<f32> = input.fragUV;\r\n\tvar n : f32 = f32((radius + 1) * (radius + 1));\r\n\t\r\n\tvar m : array<vec3<f32>, 4> = array<vec3<f32>, 4>(vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));\r\n\tvar s : array<vec3<f32>, 4> = array<vec3<f32>, 4>(vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));\r\n\t\r\n\tfor (var j : i32 = -radius; j <= 0; j = j + 1)\r\n\t{\r\n\t\tfor (var i : i32 = -radius; i <= 0; i = i + 1)\r\n\t\t{\r\n\t\t\tvar c : vec3<f32> = textureSample(textureFront, samplerFront, uv + vec2<f32>(f32(i), f32(j)) / src_size).rgb;\r\n\t\t\tm[0] = m[0] + c;\r\n\t\t\ts[0] = s[0] + c * c;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (var j : i32 = -radius; j <= 0; j = j + 1)\r\n\t{\r\n\t\tfor (var i : i32 = 0; i <= radius; i = i + 1)\r\n\t\t{\r\n\t\t\tvar c : vec3<f32> = textureSample(textureFront, samplerFront, uv + vec2<f32>(f32(i), f32(j)) / src_size).rgb;\r\n\t\t\tm[1] = m[1] + c;\r\n\t\t\ts[1] = s[1] + c * c;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (var j : i32 = 0; j <= radius; j = j + 1)\r\n\t{\r\n\t\tfor (var i : i32 = 0; i <= radius; i = i + 1)\r\n\t\t{\r\n\t\t\tvar c : vec3<f32> = textureSample(textureFront, samplerFront, uv + vec2<f32>(f32(i), f32(j)) / src_size).rgb;\r\n\t\t\tm[2] = m[2] + c;\r\n\t\t\ts[2] = s[2] + c * c;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (var j : i32 = 0; j <= radius; j = j + 1)\r\n\t{\r\n\t\tfor (var i : i32 = -radius; i <= 0; i = i + 1)\r\n\t\t{\r\n\t\t\tvar c : vec3<f32> = textureSample(textureFront, samplerFront, uv + vec2<f32>(f32(i), f32(j)) / src_size).rgb;\r\n\t\t\tm[3] = m[3] + c;\r\n\t\t\ts[3] = s[3] + c * c;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvar output : FragmentOutput;\r\n\tvar min_sigma2 : f32 = 100.0;\r\n\tfor (var k : i32 = 0; k < 4; k = k + 1)\r\n\t{\r\n\t\tm[k] = m[k] / n;\r\n\t\ts[k] = abs(s[k] / n - m[k] * m[k]);\r\n\t\t\r\n\t\tvar sigma2 : f32 = s[k].r + s[k].g + s[k].b;\r\n\t\tif (sigma2 < min_sigma2)\r\n\t\t{\r\n\t\t\tmin_sigma2 = sigma2;\r\n\t\t\toutput.color = vec4<f32>(m[k], alpha);\r\n\t\t}\r\n\t}\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"overlay","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Overlay effect\r\n\r\n// Edge fails shader compilation without this - see: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14342519/\r\nprecision mediump float;\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tfront.r = back.r < 0.5 ? 2.0 * back.r * front.r : 2.0 * (front.r + back.r * front.a - back.r * front.r) - front.a;\r\n\tfront.g = back.g < 0.5 ? 2.0 * back.g * front.g : 2.0 * (front.g + back.g * front.a - back.g * front.g) - front.a;\r\n\tfront.b = back.b < 0.5 ? 2.0 * back.b * front.b : 2.0 * (front.b + back.b * front.a - back.b * front.b) - front.a;\r\n\tfront *= back.a;\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\t\r\n\tvar rgb : vec3<f32> = select(\r\n\t\t2.0 * (front.rgb + back.rgb * front.a - back.rgb * front.rgb) - front.a,\r\n\t\t2.0 * back.rgb * front.rgb,\r\n\t\tback.rgb < vec3<f32>(0.5)\r\n\t);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb, front.a) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"pixellate","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"size","type":"float","initial-value":16,"interpolatable":true,"uniform":"tilesize"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Pixellate effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\n\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float tilesize;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 tile = pixelSize * tilesize;\r\n\tmediump vec2 halftile = tile / 2.0;\r\n\t\r\n\tmediump vec2 tex = floor(vTex / tile) * tile + halftile;\r\n\t\r\n\ttex = clamp(tex, min(srcOriginStart, srcOriginEnd), max(srcOriginStart, srcOriginEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttilesize : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tile : vec2<f32> = vec2<f32>(shaderParams.tilesize) / vec2<f32>(textureDimensions(textureFront));\r\n\tvar halftile : vec2<f32> = tile / 2.0;\r\n\t\r\n\tvar tex : vec2<f32> = floor(input.fragUV / tile) * tile + halftile;\r\n\t\r\n\ttex = c3_clampToSrcOrigin(tex);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"pixellatemask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"size","type":"float","initial-value":16,"interpolatable":true,"uniform":"tilesize"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Pixellate mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float tilesize;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 tilecount = (1.0 / pixelSize) / tilesize;\r\n\tmediump vec2 tile = vec2(1.0 / tilecount.x, 1.0 / tilecount.y);\r\n\tmediump vec2 halftile = tile / 2.0;\r\n\t\r\n\tmediump vec2 tex = floor(vTex / tile) * tile + halftile;\r\n\ttex = clamp(tex, min(srcStart, srcEnd), max(srcStart, srcEnd));\r\n\ttex = (tex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback *= fronta;\r\n\tgl_FragColor = back;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttilesize : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\r\n\tvar tilecount : vec2<f32> = vec2<f32>(textureDimensions(textureFront)) / shaderParams.tilesize;\r\n\tvar tile : vec2<f32> = 1.0 / tilecount;\r\n\tvar halftile : vec2<f32> = tile / 2.0;\r\n\r\n\tvar tex : vec2<f32> = floor(input.fragUV / tile) * tile + halftile;\r\n\ttex = c3_clampToSrc(tex);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, c3_srcToDest(tex)) * fronta;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"polarinvert","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Polar invert effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp float intensity;\r\nconst mediump float PI = 3.1415926;\r\n\r\nvoid main(void)\r\n{\r\n\t// retrieve tex in normalised [0, 1] range regardless of source rect\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\ttex = tex * 2.0 - 1.0;\t\t// convert to [-1, 1] range\r\n\t\r\n\t// Swap distance and angle parameters\r\n\tmediump float d = length(tex);\r\n\tmediump float a = atan(tex.y, tex.x);\r\n\t\r\n\tif (a < 0.0)\r\n\t\ta += PI;\r\n\t\r\n\tmediump float temp = a;\r\n\ta = d * 2.0 * PI;\r\n\td = temp / (2.0 * PI);\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\t\t\t// convert back to [0, 1] range\r\n\ttex = clamp(tex, 0.0, 1.0);\t\t\t// ensure no sampling outside source rect\r\n\ttex = (tex * srcSize) + srcStart;\t// convert back relative to source rect\r\n\ttex = mix(vTex, tex, intensity);\t// apply intensity\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet PI : f32 = 3.1415926;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// retrieve tex in normalised [0, 1] range regardless of source rect\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\ttex = tex * 2.0 - 1.0;\t\t// convert to [-1, 1] range\r\n\t\r\n\t// Swap distance and angle parameters\r\n\tvar d : f32 = length(tex);\r\n\tvar a = atan2(tex.y, tex.x);\r\n\t\r\n\tif (a < 0.0)\r\n\t{\r\n\t\ta = a + PI;\r\n\t}\r\n\t\r\n\tvar temp : f32 = a;\r\n\ta = d * 2.0 * PI;\r\n\td = temp / (2.0 * PI);\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\t\t\t\t\t\t\t\t// convert back to [0, 1] range\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\t\t\t\t\t\t\t// ensure no sampling outside source rect\r\n\ttex = c3_normToSrc(tex);\t\t\t\t\t\t\t\t// convert back relative to source rect\r\n\ttex = mix(input.fragUV, tex, shaderParams.intensity);\t// apply intensity\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"polkadot","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"dot-size","type":"percent","initial-value":0.05,"interpolatable":true,"uniform":"dotSize"},{"id":"dot-scale","type":"percent","initial-value":0.9,"interpolatable":true,"uniform":"dotScale"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Polka dot effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float dotSize;\r\nuniform mediump float dotScale;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float aspectRatio = pixelSize.x / pixelSize.y;\r\n\tmediump vec2 sampleDivisor = vec2(dotSize, dotSize / aspectRatio);\r\n\r\n\tmediump vec2 samplePos = vTex - mod(vTex, sampleDivisor) + 0.5 * sampleDivisor;\r\n\tmediump vec2 textureCoordinateToUse = vec2(vTex.x, (vTex.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tmediump vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tmediump float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\r\n\tlowp float checkForPresenceWithinDot = step(distanceFromSamplePoint, (dotSize * 0.5) * dotScale);\r\n\r\n\tgl_FragColor = texture2D(samplerFront, samplePos) * checkForPresenceWithinDot;\r\n}\r\n","wgsl":"// Polka dot effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tdotSize : f32,\r\n\tdotScale : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar texSize : vec2<i32> = textureDimensions(textureFront);\r\n\tvar aspectRatio : f32 = f32(texSize.x) / f32(texSize.y);\r\n\tvar sampleDivisor : vec2<f32> = vec2<f32>(shaderParams.dotSize, shaderParams.dotSize / aspectRatio);\r\n\t\r\n\tvar samplePos : vec2<f32> = input.fragUV - c3_mod2(input.fragUV, sampleDivisor) + sampleDivisor * 0.5;\r\n\tvar textureCoordinateToUse : vec2<f32> = vec2<f32>(input.fragUV.x, (input.fragUV.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tvar adjustedSamplePos : vec2<f32> = vec2<f32>(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tvar distanceFromSamplePoint : f32 = distance(adjustedSamplePos, textureCoordinateToUse);\r\n\tvar checkForPresenceWithinDot : f32 = step(distanceFromSamplePoint, (shaderParams.dotSize * 0.5) * shaderParams.dotScale);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, samplePos) * checkForPresenceWithinDot;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"posterize","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"levels","type":"float","initial-value":4,"interpolatable":true,"uniform":"levels"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Posterize effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nuniform mediump float levels;\r\n\r\nvoid main(void)\r\n{\t\r\n\t// Retrieve source pixel and unpremultiply\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= a;\r\n\t\r\n\t// Posterize and premultiply\r\n\tfront.rgb = floor(front.rgb * (levels-1.0) + vec3(0.5)) / (levels-1.0);\r\n\t\r\n\tfront.rgb *= a;\r\n\t\r\n\t// Output posterized pixel\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tlevels : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\t\r\n\t// Output posterized pixel premultiplied\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(floor(front.rgb * (shaderParams.levels - 1.0) + vec3<f32>(0.5)) / (shaderParams.levels - 1.0) * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"posterizemask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"levels","type":"float","initial-value":4,"interpolatable":true,"uniform":"levels"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Posterize Mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform mediump float levels;\r\n\r\nvoid main(void)\r\n{\t\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back1 = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tlowp vec4 back2 = back1;\r\n\tback2.rgb /= back2.a;\r\n\t\r\n\t// Posterize and premultiply\r\n\tback2.rgb = floor(back2.rgb * (levels-1.0) + vec3(0.5)) / (levels-1.0);\r\n\tback2.rgb *= back2.a;\r\n\t\r\n\t// Output posterized pixel\r\n\tgl_FragColor = mix(back1, back2, fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tlevels : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back1 : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\tvar back2 : vec4<f32> = c3_unpremultiply(back1);\r\n\t\r\n\t// Posterize and premultiply\r\n\tback2 = c3_premultiply(vec4<f32>(floor(back2.rgb * (shaderParams.levels - 1.0) + vec3<f32>(0.5)) / (shaderParams.levels - 1.0), back2.a));\r\n\r\n\t// Output posterized pixel\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back1, back2, fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"pulse","category":"distortion","author":"Danguafer/Silexars","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":50,"vertical":50},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"},{"id":"lighting","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"lighting"},{"id":"speed","type":"float","initial-value":10,"interpolatable":true,"uniform":"speed"},{"id":"frequency","type":"float","initial-value":30,"interpolatable":true,"uniform":"frequency"},{"id":"center-x","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"centerX"},{"id":"center-y","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"centerY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Pulse effect\r\n// Based on code by Danguafer/Silexars, used with permission\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp float intensity;\r\nuniform lowp float lighting;\r\nuniform mediump float frequency;\r\nuniform mediump float speed;\r\nuniform mediump float centerX;\r\nuniform mediump float centerY;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\nuniform highmedp float seconds;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = (vTex - srcStart) / srcSize;\r\n\tmediump vec2 res = 1.0 / pixelSize;\r\n\tmediump vec2 halfres = res / 2.0;\r\n    mediump vec2 cPos = (tex - vec2(centerX, 1.0 - centerY)) * res;\r\n    mediump float cLength = length(cPos);\r\n\r\n    mediump vec2 uv = tex+(cPos/cLength)*sin(cLength/frequency/(devicePixelRatio*layerScale)-seconds*speed)/25.0;\r\n\ttex = mix(tex, uv, intensity);\r\n\ttex = clamp(tex, 0.0, 1.0);\r\n\ttex = tex * srcSize + srcStart;\r\n\tlowp vec4 front = texture2D(samplerFront, tex);\r\n    lowp vec3 col = mix(front.rgb, front.rgb*50.0/cLength, lighting * intensity);\r\n\r\n    gl_FragColor = vec4(col,front.a);\r\n}\r\n","wgsl":"// Pulse effect\r\n// Based on code by Danguafer/Silexars, used with permission\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32,\r\n\tlighting : f32,\r\n\tspeed : f32,\r\n\tfrequency : f32,\r\n\tcenterX : f32,\r\n\tcenterY : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar res : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\r\n\tvar halfres : vec2<f32> = res / 2.0;\r\n\tvar cPos : vec2<f32> = (tex - vec2<f32>(shaderParams.centerX, 1.0 - shaderParams.centerY)) * res;\r\n\tvar cLength : f32 = length(cPos);\r\n\t\r\n\tvar uv : vec2<f32> = tex + (cPos / cLength) * sin(cLength / shaderParams.frequency / (c3Params.devicePixelRatio * c3Params.layerScale) - c3Params.seconds * shaderParams.speed) / 25.0;\r\n\t\r\n\ttex = mix(tex, uv, shaderParams.intensity);\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\r\n\ttex = c3_normToSrc(tex);\r\n\t\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, tex);\r\n\tvar col : vec3<f32> = mix(front.rgb, front.rgb * 50.0 / cLength, shaderParams.lighting * shaderParams.intensity);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(col, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"radialblur","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":50,"vertical":50},"parameters":[{"id":"radius","type":"percent","initial-value":0.4,"interpolatable":true,"uniform":"radius"},{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Radial blur effect\r\nprecision mediump float;\r\nvarying vec2 vTex;\r\nuniform sampler2D samplerFront;\r\nuniform vec2 srcStart;\r\nuniform vec2 srcEnd;\r\nuniform float devicePixelRatio;\r\nuniform float layerScale;\r\n\r\nuniform float intensity;\r\nuniform float radius;\r\n\r\nvoid main(void)\r\n{\r\n\tvec2 dir = ((srcStart + srcEnd) / 2.0 - vTex) / (length(srcEnd - srcStart) / 2.0); \r\n\tfloat dist = sqrt(dir.x*dir.x + dir.y*dir.y); \r\n\tdir = dir/dist; \r\n\tvec4 front = texture2D(samplerFront, vTex); \r\n\r\n\tvec4 sum = front;\r\n\tfloat scaledRadius = radius * devicePixelRatio * layerScale;\r\n\r\n\tsum += texture2D(samplerFront, vTex + dir * -0.08 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * -0.05 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * -0.03 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * -0.02 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * -0.01 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * 0.01 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * 0.02 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * 0.03 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * 0.05 * scaledRadius);\r\n\tsum += texture2D(samplerFront, vTex + dir * 0.08 * scaledRadius);\r\n\r\n\tsum /= 11.0;\r\n\r\n\tfloat t = dist * 2.2;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\r\n\tgl_FragColor = mix(front, mix(front, sum, t), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tradius : f32,\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\tvar dir : vec2<f32> = ((c3Params.srcStart + c3Params.srcEnd) / 2.0 - input.fragUV) / (length(c3Params.srcEnd - c3Params.srcStart) / 2.0); \r\n\tvar dist : f32 = length(dir); \r\n\tdir = dir / dist;\r\n\tvar scaledRadius = shaderParams.radius * c3Params.devicePixelRatio * c3Params.layerScale;\r\n\r\n\t// Add 11 samples\r\n\tvar sum : vec4<f32> =\r\n\t\tfront +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir * -0.08 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir * -0.05 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir * -0.03 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir * -0.02 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir * -0.01 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir *  0.01 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir *  0.02 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir *  0.03 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir *  0.05 * scaledRadius) +\r\n\t\ttextureSample(textureFront, samplerFront, input.fragUV + dir *  0.08 * scaledRadius);\r\n\t\r\n\tsum = sum / 11.0;\r\n\t\r\n\tvar t : f32 = clamp(dist * 2.2, 0.0, 1.0);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, mix(front, sum, t), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"radialpixellate","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"size","type":"float","initial-value":16,"interpolatable":true,"uniform":"tilesize"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Radial pixellate effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\n\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float tilesize;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\t\r\n\thighmedp vec2 normCoord = 2.0 * tex - 1.0;\r\n\r\n\thighmedp float r = length(normCoord);\r\n\thighmedp float phi = atan(normCoord.y, normCoord.x);\r\n\t\r\n\tr = r - mod(r, pixelSize.x * tilesize / srcSize.x);\r\n\tphi = phi - mod(phi, pixelSize.y * tilesize / srcSize.y);\r\n\t\r\n\tnormCoord.x = r * cos(phi);\r\n\tnormCoord.y = r * sin(phi);\r\n\t\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = clamp(normCoord, 0.0, 1.0);\t\t\t// ensure no sampling outside source rect\r\n\tnormCoord = (normCoord * srcSize) + srcStart;\t// convert back relative to source rect\r\n\r\n\tgl_FragColor = texture2D(samplerFront, normCoord);\r\n}\r\n","wgsl":"// Radial pixellate effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttilesize : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar srcSize : vec2<f32> = c3Params.srcEnd - c3Params.srcStart;\r\n\tvar tex = c3_srcToNorm(input.fragUV);\r\n\r\n\tvar normCoord : vec2<f32> = tex * 2.0 - 1.0;\r\n\r\n\tvar r : f32 = length(normCoord);\r\n\tvar phi : f32 = atan2(normCoord.y, normCoord.x);\r\n\r\n\tr = r - c3_mod(r, pixelSize.x * shaderParams.tilesize / srcSize.x);\r\n\tphi = phi - c3_mod(phi, pixelSize.y * shaderParams.tilesize / srcSize.y);\r\n\r\n\tnormCoord.x = r * cos(phi);\r\n\tnormCoord.y = r * sin(phi);\r\n\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = c3_clamp2(normCoord, 0.0, 1.0);\t\t// ensure no sampling outside source rect\r\n\tnormCoord = c3_normToSrc(normCoord);\t\t\t// convert back relative to source rect\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, normCoord);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"radialpixellatemask","category":"mask","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"size","type":"float","initial-value":16,"interpolatable":true,"uniform":"tilesize"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Radial pixellate effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float tilesize;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front alpha\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\t\r\n\thighmedp vec2 normCoord = 2.0 * tex - 1.0;\r\n\r\n\thighmedp float r = length(normCoord);\r\n\thighmedp float phi = atan(normCoord.y, normCoord.x);\r\n\t\r\n\tr = r - mod(r, pixelSize.x * tilesize / srcSize.x);\r\n\tphi = phi - mod(phi, pixelSize.y * tilesize / srcSize.y);\r\n\t\r\n\tnormCoord.x = r * cos(phi);\r\n\tnormCoord.y = r * sin(phi);\r\n\t\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = clamp(normCoord, 0.0, 1.0);\t\t\t// ensure no sampling outside source rect\r\n\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, normCoord));\r\n\tback *= fronta;\r\n\tgl_FragColor = back;\r\n}\r\n","wgsl":"// Radial pixellate effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttilesize : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\t\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar srcSize : vec2<f32> = c3Params.srcEnd - c3Params.srcStart;\r\n\tvar tex = c3_srcToNorm(input.fragUV);\r\n\r\n\tvar normCoord : vec2<f32> = tex * 2.0 - 1.0;\r\n\r\n\tvar r : f32 = length(normCoord);\r\n\tvar phi : f32 = atan2(normCoord.y, normCoord.x);\r\n\r\n\tr = r - c3_mod(r, pixelSize.x * shaderParams.tilesize / srcSize.x);\r\n\tphi = phi - c3_mod(phi, pixelSize.y * shaderParams.tilesize / srcSize.y);\r\n\r\n\tnormCoord.x = r * cos(phi);\r\n\tnormCoord.y = r * sin(phi);\r\n\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = c3_clamp2(normCoord, 0.0, 1.0);\t\t// ensure no sampling outside source rect\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, mix(c3Params.destStart, c3Params.destEnd, normCoord)) * fronta;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"replacecolor","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"source-color","type":"color","initial-value":[1,1,1],"interpolatable":true,"uniform":"sourceColor","c2id":"r-source,g-source,b-source"},{"id":"replace-color","type":"color","initial-value":[0,0,0],"interpolatable":true,"uniform":"destColor","c2id":"r-replace,g-replace,b-replace"},{"id":"tolerance","type":"percent","initial-value":0.01,"interpolatable":true,"uniform":"tolerance"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Replace color effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp vec3 sourceColor;\r\nuniform lowp vec3 destColor;\r\nuniform lowp float tolerance;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= a;\r\n\t\r\n\t// Calculate distance from source color\r\n\tlowp float diff = length(front.rgb - sourceColor);\r\n\t\r\n\tif (diff <= tolerance)\r\n\t{\r\n\t\tfront.rgb = mix(front.rgb, destColor, 1.0 - diff / tolerance);\r\n\t}\r\n\t\r\n\tfront.rgb *= a;\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tsourceColor : vec3<f32>,\r\n\tdestColor : vec3<f32>,\r\n\ttolerance : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar rgb : vec3<f32> = front.rgb;\r\n\r\n\t// Calculate distance from source color\r\n\tvar diff : f32 = length(rgb - shaderParams.sourceColor);\r\n\t\r\n\tif (diff <= shaderParams.tolerance)\r\n\t{\r\n\t\trgb = mix(rgb, shaderParams.destColor, 1.0 - diff / shaderParams.tolerance);\r\n\t}\r\n\r\n\t// Premultiply and output\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"replacesolidcolor","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"source-color","type":"color","initial-value":[1,1,1],"interpolatable":true,"uniform":"sourceColor"},{"id":"replace-color","type":"color","initial-value":[0,0,0],"interpolatable":true,"uniform":"destColor"},{"id":"tolerance","type":"percent","initial-value":0.01,"interpolatable":true,"uniform":"tolerance"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Replace color effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp vec3 sourceColor;\r\nuniform lowp vec3 destColor;\r\nuniform lowp float tolerance;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= a;\r\n\t\r\n\t// Calculate distance from source color\r\n\tlowp float diff = length(front.rgb - sourceColor);\r\n\t\r\n\tif (diff <= tolerance)\r\n\t{\r\n\t\tfront.rgb = destColor;\r\n\t}\r\n\t\r\n\tfront.rgb *= a;\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tsourceColor : vec3<f32>,\r\n\tdestColor : vec3<f32>,\r\n\ttolerance : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar rgb : vec3<f32> = front.rgb;\r\n\r\n\t// Calculate distance from source color\r\n\tvar diff : f32 = length(rgb - shaderParams.sourceColor);\r\n\t\r\n\tif (diff <= shaderParams.tolerance)\r\n\t{\r\n\t\trgb = shaderParams.destColor;\r\n\t}\r\n\r\n\t// Premultiply and output\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"satblend","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Saturation effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nprecision mediump float;\r\n\r\nvec3 rgb_to_hsl(vec3 color)\r\n{\r\n\tvec3 hsl = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tfloat fmin = min(min(color.r, color.g), color.b);\r\n\tfloat fmax = max(max(color.r, color.g), color.b);\r\n\tfloat delta = fmax - fmin;\r\n\r\n\thsl.z = (fmax + fmin) / 2.0;\r\n\r\n\tif (delta == 0.0)\r\n\t{\r\n\t\thsl.x = 0.0;\r\n\t\thsl.y = 0.0;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\thsl.y = delta / (fmax + fmin);\r\n\t\telse\r\n\t\t\thsl.y = delta / (2.0 - fmax - fmin);\r\n\t\t\r\n\t\tfloat dR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\r\n\t\tfloat dB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\r\n\r\n\t\tif (color.r == fmax)\r\n\t\t\thsl.x = dB - dG;\r\n\t\telse if (color.g == fmax)\r\n\t\t\thsl.x = (1.0 / 3.0) + dR - dB;\r\n\t\telse if (color.b == fmax)\r\n\t\t\thsl.x = (2.0 / 3.0) + dG - dR;\r\n\r\n\t\tif (hsl.x < 0.0)\r\n\t\t\thsl.x += 1.0;\r\n\t\telse if (hsl.x > 1.0)\r\n\t\t\thsl.x -= 1.0;\r\n\t}\r\n\r\n\treturn hsl;\r\n}\r\n\r\nfloat hue_to_rgb(float f1, float f2, float hue)\r\n{\r\n\tif (hue < 0.0)\r\n\t\thue += 1.0;\r\n\telse if (hue > 1.0)\r\n\t\thue -= 1.0;\r\n\t\t\r\n\tfloat ret;\r\n\t\r\n\tif ((6.0 * hue) < 1.0)\r\n\t\tret = f1 + (f2 - f1) * 6.0 * hue;\r\n\telse if ((2.0 * hue) < 1.0)\r\n\t\tret = f2;\r\n\telse if ((3.0 * hue) < 2.0)\r\n\t\tret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\r\n\telse\r\n\t\tret = f1;\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nvec3 hsl_to_rgb(vec3 hsl)\r\n{\r\n\tvec3 rgb = vec3(hsl.z);\r\n\t\r\n\tif (hsl.y != 0.0)\r\n\t{\r\n\t\tfloat f2;\r\n\t\t\r\n\t\tif (hsl.z < 0.5)\r\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\r\n\t\telse\r\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\r\n\t\t\t\r\n\t\tfloat f1 = 2.0 * hsl.z - f2;\r\n\t\t\r\n\t\trgb.r = hue_to_rgb(f1, f2, hsl.x + (1.0 / 3.0));\r\n\t\trgb.g = hue_to_rgb(f1, f2, hsl.x);\r\n\t\trgb.b = hue_to_rgb(f1, f2, hsl.x - (1.0 / 3.0));\r\n\t}\r\n\t\r\n\treturn rgb;\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\tvec3 fronthsl = rgb_to_hsl(front.rgb / front.a);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tvec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tvec3 backhsl = rgb_to_hsl(back.rgb / back.a);\r\n\r\n\t// Use saturation of front and hue and luminosity of back\r\n\tfronthsl = hsl_to_rgb(vec3(backhsl.x, fronthsl.y, backhsl.z));\r\n\tfronthsl *= front.a;\r\n\r\n\tgl_FragColor = vec4(fronthsl.r, fronthsl.g, fronthsl.b, front.a) * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar fronthsl : vec3<f32> = c3_RGBtoHSL(front.rgb);\r\n\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\tvar backhsl : vec3<f32> = c3_RGBtoHSL(back.rgb);\r\n\r\n\t// Use saturation of front and hue and luminosity of back\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\tc3_HSLtoRGB(vec3<f32>(backhsl.x, fronthsl.y, backhsl.z)) * front.a,\r\n\t\tfront.a\r\n\t) * back.a;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"scanlines","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"line-height","type":"float","initial-value":2,"interpolatable":true,"uniform":"lineHeight"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Scanlines effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float lineHeight;\r\n\r\nvoid main(void)\r\n{\t\r\n\t// Retrieve source pixel\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\t// Darken if an alternate row\r\n\tmediump float factor = 1.0 + (floor(mod(vTex.y, pixelSize.y * lineHeight * 2.0) / (pixelSize.y * lineHeight)) / 3.0);\r\n\tfront.rgb /= factor;\r\n\t\r\n\t// Output a gray pixel with source alpha\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tlineHeight : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSizeY : f32 = c3_getPixelSize(textureFront).y;\r\n\r\n\t// Retrieve source pixel\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\r\n\t// Darken if an alternate row\r\n\tvar factor : f32 = 1.0 + (floor(c3_mod(input.fragUV.y, pixelSizeY * shaderParams.lineHeight * 2.0) / (pixelSizeY * shaderParams.lineHeight)) / 3.0);\r\n\r\n\t// Output\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(front.rgb / factor, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"screen","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Multiply effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\t// Screen blend\r\n\tfront.rgb = 1.0 - ((1.0 - front.rgb) * (1.0 - back.rgb * front.a));\r\n\t\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\t// Screen blend\r\n\t\tvec3<f32>(1.0) - ((vec3<f32>(1.0) - front.rgb) * (vec3<f32>(1.0) - back.rgb * front.a)),\r\n\t\tfront.a\t\r\n\t);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"sepia","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Sepia effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve source pixel and unpremultiply\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tlowp vec4 sepia = front * mat4( 0.3588, 0.7044, 0.1368, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.2990, 0.5870, 0.1140, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.2392, 0.4696, 0.0912, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.0,\t0.0,\t0.0,\t1.0);\r\n\t\r\n\tgl_FragColor = mix(front, vec4(sepia.r, sepia.g, sepia.b, front.a), intensity);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet sepiaMatrix : mat4x4<f32> = mat4x4<f32>(\r\n\tvec4<f32>(0.3588, 0.7044, 0.1368, 0.0),\r\n\tvec4<f32>(0.2990, 0.5870, 0.1140, 0.0),\r\n\tvec4<f32>(0.2392, 0.4696, 0.0912, 0.0),\r\n\tvec4<f32>(0.0,\t0.0,\t0.0,\t1.0)\r\n);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar sepia : vec4<f32> = front * sepiaMatrix;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(front, vec4<f32>(sepia.rgb, front.a), shaderParams.intensity);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"sepiamask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Sepia Mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tlowp vec4 sepia = back * mat4( 0.3588, 0.7044, 0.1368, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.2990, 0.5870, 0.1140, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.2392, 0.4696, 0.0912, 0.0,\r\n\t\t\t\t\t\t\t\t\t0.0,\t0.0,\t0.0,\t1.0);\r\n\t\r\n\tgl_FragColor = mix(back, vec4(sepia.r, sepia.g, sepia.b, back.a), fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet sepiaMatrix : mat4x4<f32> = mat4x4<f32>(\r\n\tvec4<f32>(0.3588, 0.7044, 0.1368, 0.0),\r\n\tvec4<f32>(0.2990, 0.5870, 0.1140, 0.0),\r\n\tvec4<f32>(0.2392, 0.4696, 0.0912, 0.0),\r\n\tvec4<f32>(0.0,\t0.0,\t0.0,\t1.0)\r\n);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\t\r\n\tvar sepia : vec4<f32> = back * sepiaMatrix;\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back, vec4<f32>(sepia.rgb, back.a), fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"setcolor","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"color","type":"color","initial-value":[1,0,0],"interpolatable":true,"uniform":"setColor","c2id":"red,green,blue"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Set color effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp vec3 setColor;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp float a = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tgl_FragColor = vec4(setColor.r * a, setColor.g * a, setColor.b * a, a);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tsetColor : vec3<f32>\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar a : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(shaderParams.setColor * a, a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"sharpen","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"intensity","type":"percent","initial-value":1,"interpolatable":true,"uniform":"intensity"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Sharpen effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 pixelSize;\r\nuniform lowp float intensity;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float centerMultiplier = 1.0 + 4.0 * intensity;\r\n\t\r\n\tmediump vec4 front = texture2D(samplerFront, vTex);\r\n\tmediump vec3 textureColor = front.rgb;\r\n\tmediump vec3 leftTextureColor = texture2D(samplerFront, vTex - vec2(pixelSize.x, 0.0)).rgb;\r\n\tmediump vec3 rightTextureColor = texture2D(samplerFront, vTex + vec2(pixelSize.x, 0.0)).rgb;\r\n\tmediump vec3 topTextureColor = texture2D(samplerFront, vTex - vec2(0.0, pixelSize.y)).rgb;\r\n\tmediump vec3 bottomTextureColor = texture2D(samplerFront, vTex + vec2(0.0, pixelSize.y)).rgb;\r\n\r\n\tgl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * intensity + rightTextureColor * intensity + topTextureColor * intensity + bottomTextureColor * intensity)), front.a);\r\n}\r\n","wgsl":"// Sharpen effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tintensity : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar centerMultiplier : f32 = 1.0 + 4.0 * shaderParams.intensity;\r\n\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar textureColor : vec3<f32> = front.rgb;\r\n\tvar leftTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelSize.x, 0.0)).rgb;\r\n\tvar rightTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelSize.x, 0.0)).rgb;\r\n\tvar topTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelSize.y)).rgb;\r\n\tvar bottomTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelSize.y)).rgb;\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>((textureColor * centerMultiplier - (leftTextureColor * shaderParams.intensity + rightTextureColor * shaderParams.intensity + topTextureColor * shaderParams.intensity + bottomTextureColor * shaderParams.intensity)), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"sketch","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Sketch effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nprecision mediump float;\r\nuniform mediump vec2 pixelSize;\r\n\r\nvoid main()\r\n{\r\n\tfloat dx = pixelSize.x;\r\n\tfloat dy = pixelSize.y;\r\n\t\r\n    float bottomLeftIntensity = texture2D(samplerFront, vTex + vec2(-dx, dy)).r;\r\n    float topRightIntensity = texture2D(samplerFront, vTex + vec2(dx, -dy)).r;\r\n    float topLeftIntensity = texture2D(samplerFront, vTex + vec2(-dx, -dy)).r;\r\n    float bottomRightIntensity = texture2D(samplerFront, vTex + vec2(dx, dy)).r;\r\n    float leftIntensity = texture2D(samplerFront, vTex + vec2(-dx, 0.0)).r;\r\n    float rightIntensity = texture2D(samplerFront, vTex + vec2(dx, 0.0)).r;\r\n    float bottomIntensity = texture2D(samplerFront, vTex + vec2(0.0, dy)).r;\r\n    float topIntensity = texture2D(samplerFront, vTex + vec2(0.0, -dy)).r;\r\n    float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\r\n    float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\r\n    \r\n    float mag = 1.0 - length(vec2(h, v));\r\n\tfloat a = texture2D(samplerFront, vTex).a;\r\n     \r\n    gl_FragColor = vec4(vec3(mag) * a, a);\r\n}","wgsl":"// Sketch effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar dx : f32 = pixelSize.x;\r\n\tvar dy : f32 = pixelSize.y;\r\n\r\n\tvar a : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar bottomLeftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, dy)).r;\r\n    var topRightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, -dy)).r;\r\n    var topLeftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, -dy)).r;\r\n    var bottomRightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, dy)).r;\r\n    var leftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, 0.0)).r;\r\n    var rightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, 0.0)).r;\r\n    var bottomIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, dy)).r;\r\n    var topIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, -dy)).r;\r\n\r\n\tvar h : f32 = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\r\n    var v : f32 = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\r\n\tvar mag : f32 = 1.0 - length(vec2<f32>(h, v));\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(vec3<f32>(mag) * a, a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"softlight","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Soft light effect\r\nprecision mediump float;\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\tfront.r = ((front.r < 0.5) ? (2.0 * back.r * front.r + back.r * back.r * (1.0 - 2.0 * front.r)) : (sqrt(back.r) * (2.0 * front.r - 1.0) + 2.0 * back.r * (1.0 - front.r)));\r\n\tfront.g = ((front.g < 0.5) ? (2.0 * back.g * front.g + back.g * back.g * (1.0 - 2.0 * front.g)) : (sqrt(back.g) * (2.0 * front.g - 1.0) + 2.0 * back.g * (1.0 - front.g)));\r\n\tfront.b = ((front.b < 0.5) ? (2.0 * back.b * front.b + back.b * back.b * (1.0 - 2.0 * front.b)) : (sqrt(back.b) * (2.0 * front.b - 1.0) + 2.0 * back.b * (1.0 - front.b)));\r\n\tfront.rgb *= front.a;\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\t\r\n\tvar rgb : vec3<f32> = select(\r\n\t\tsqrt(back.rgb) * (2.0 * front.rgb - 1.0) + 2.0 * back.rgb * (1.0 - front.rgb),\r\n\t\t2.0 * back.rgb * front.rgb + back.rgb * back.rgb * (1.0 - 2.0 * front.rgb),\r\n\t\tfront.rgb < vec3<f32>(0.5)\r\n\t);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb * front.a * back.a, front.a * back.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"sphere","category":"distortion","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"radius","type":"percent","initial-value":0.33,"interpolatable":true,"uniform":"radius"},{"id":"refractive-index","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"refractiveIndex"},{"id":"progress","type":"percent","initial-value":1,"interpolatable":true,"uniform":"progress"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Sphere effect\r\n// Based on the glass sphere filter from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform mediump vec2 layoutStart;\r\nuniform mediump vec2 layoutEnd;\r\n\r\nuniform highmedp float radius;\r\nuniform highmedp float refractiveIndex;\r\nuniform highmedp float progress;\r\n\r\nvoid main(void)\r\n{\r\n\thighmedp vec2 srcSize = srcOriginEnd - srcOriginStart;\r\n\thighmedp vec2 tex = (vTex - srcOriginStart) / srcSize;\r\n\thighmedp vec2 center = vec2(0.5, 0.5);\r\n\thighmedp vec2 layoutSize = layoutEnd - layoutStart;\r\n\thighmedp float aspectRatio = layoutSize.y / layoutSize.x;\r\n\r\n\thighmedp vec2 otherTex = vec2(1.0 - tex.x, (tex.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\thighmedp float distanceFromCenter = distance(center, otherTex);\r\n\tlowp float checkForPresenceWithinSphere = mix(1.0, step(distanceFromCenter, radius), progress);\r\n\r\n\tdistanceFromCenter = distanceFromCenter / radius;\r\n\r\n\thighmedp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\r\n\thighmedp vec3 sphereNormal = normalize(vec3(otherTex - center, normalizedDepth));\r\n\r\n\thighmedp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\r\n\r\n\ttex = mix(tex, ((refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere, progress);\r\n\ttex = clamp(tex, 0.0, 1.0);\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, mix(srcOriginStart, srcOriginEnd, tex));\r\n}\r\n","wgsl":"// Sphere effect\r\n// Based on the glass sphere filter from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tradius : f32,\r\n\trefractiveIndex : f32,\r\n\tprogress : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tex : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\tvar center : vec2<f32> = vec2<f32>(0.5);\r\n\tvar layoutSize : vec2<f32> = c3Params.layoutEnd - c3Params.layoutStart;\r\n\tvar aspectRatio : f32 = layoutSize.y / layoutSize.x;\r\n\t\r\n\tvar otherTex : vec2<f32> = vec2<f32>(1.0 - tex.x, ((1.0 - tex.y) * aspectRatio + 0.5 - 0.5 * aspectRatio));\r\n\tvar distanceFromCenter : f32 = distance(center, otherTex);\r\n\tvar checkForPresenceWithinSphere = mix(1.0, step(distanceFromCenter, shaderParams.radius), shaderParams.progress);\r\n\t\r\n\tdistanceFromCenter = distanceFromCenter / shaderParams.radius;\r\n\t\r\n\tvar normalizedDepth : f32 = shaderParams.radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\r\n\tvar sphereNormal : vec3<f32> = normalize(vec3<f32>(otherTex - center, normalizedDepth));\r\n\tvar refractedVector : vec3<f32> = refract(vec3<f32>(0.0, 0.0, -1.0), sphereNormal, shaderParams.refractiveIndex);\r\n\t\r\n\ttex = mix(tex, ((refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere, shaderParams.progress);\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, mix(c3Params.srcOriginStart, c3Params.srcOriginEnd, tex));\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"stretch","category":"distortion","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Stretch effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\n\r\nvoid main(void)\r\n{\r\n\thighmedp vec2 center = vec2(0.5, 0.5);\r\n\thighmedp vec2 tex = (vTex - srcOriginStart) / (srcOriginEnd - srcOriginStart);\r\n\thighmedp vec2 normCoord = 2.0 * tex - 1.0;\r\n\thighmedp vec2 normCenter = 2.0 * center - 1.0;\r\n\r\n\tnormCoord -= normCenter;\r\n\tmediump vec2 s = sign(normCoord);\r\n\tnormCoord = abs(normCoord);\r\n\tnormCoord = 0.5 * normCoord + 0.5 * smoothstep(0.25, 0.5, normCoord) * normCoord;\r\n\tnormCoord = s * normCoord;\r\n\r\n\tnormCoord += normCenter;\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = clamp(normCoord, 0.0, 1.0);\r\n\r\n\tgl_FragColor = texture2D(samplerFront, mix(srcOriginStart, srcOriginEnd, normCoord));\r\n}\r\n","wgsl":"// Stretch effect\r\n// Based on code from: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar center : vec2<f32> = vec2<f32>(0.5);\r\n\tvar tex : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\tvar normCoord : vec2<f32> = tex * 2.0 - 1.0;\r\n\tvar normCenter : vec2<f32> = center * 2.0 - 1.0;\r\n\t\r\n\tnormCoord = normCoord - normCenter;\r\n\tvar s : vec2<f32> = sign(normCoord);\r\n\tnormCoord = abs(normCoord);\r\n\tnormCoord = normCoord * 0.5 + smoothstep(vec2<f32>(0.25), vec2<f32>(0.5), normCoord) * normCoord * 0.5;\r\n\tnormCoord = s * normCoord;\r\n\t\r\n\tnormCoord = normCoord + normCenter;\r\n\tnormCoord = normCoord / 2.0 + 0.5;\r\n\tnormCoord = c3_clamp2(normCoord, 0.0, 1.0);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, mix(c3Params.srcOriginStart, c3Params.srcOriginEnd, normCoord));\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"subtract","category":"blend","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[]},"glsl":"/////////////////////////////////////////////////////////\r\n// Subtract effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tfront.rgb /= front.a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\tback.rgb /= back.a;\r\n\t\r\n\t// Subtract front from back and premultiply\r\n\tfront.rgb = max(back.rgb - front.rgb, vec3(0.0, 0.0, 0.0));\r\n\tfront.rgb *= front.a;\r\n\t\r\n\tgl_FragColor = front * back.a;\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\t// Retrieve front and back pixels and unpremultiply\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar back : vec4<f32> = c3_unpremultiply(textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack)));\r\n\t\r\n\t// Subtract front from back and premultiply\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(\r\n\t\tmax(back.rgb - front.rgb, vec3<f32>(0.0)) * front.a * back.a,\r\n\t\tfront.a * back.a\r\n\t);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"swirl","category":"distortion","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"radius","type":"percent","initial-value":0.5,"interpolatable":true,"uniform":"radius"},{"id":"angle","type":"percent","initial-value":1,"interpolatable":true,"uniform":"angle"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Swirl effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\n\r\nuniform mediump float radius;\r\nuniform mediump float angle;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 center = vec2(0.5, 0.5);\r\n\t\r\n\t// convert back to [0, 1] range across source rectangle\r\n\thighmedp vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\thighmedp vec2 tex = ((vTex - srcOriginStart) / srcOriginSize);\r\n\t\r\n\thighmedp float dist = distance(center, tex);\r\n\ttex -= center;\r\n\t\r\n\tif (dist < radius)\r\n\t{\r\n\t\thighmedp float percent = (radius - dist) / radius;\r\n\t\thighmedp float theta = percent * percent * angle * 8.0;\r\n\t\thighmedp float s = sin(theta);\r\n\t\thighmedp float c = cos(theta);\r\n\t\ttex = vec2(dot(tex, vec2(c, -s)), dot(tex, vec2(s, c)));\r\n\t}\r\n\t\r\n\ttex += center;\r\n\ttex = clamp(tex, 0.0, 1.0);\t\t\t// ensure no sampling outside source rect\r\n\ttex = (tex * srcOriginSize) + srcOriginStart;\t// convert back relative to source rect\r\n\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"// Swirl effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tradius : f32,\r\n\tangle : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet center : vec2<f32> = vec2<f32>(0.5);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tex : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\tvar dist : f32 = distance(center, tex);\r\n\ttex = tex - center;\r\n\t\r\n\tif (dist < shaderParams.radius)\r\n\t{\r\n\t\tvar percent : f32 = (shaderParams.radius - dist) / shaderParams.radius;\r\n\t\tvar theta : f32 = percent * percent * shaderParams.angle * 8.0;\r\n\t\tvar s = sin(theta);\r\n\t\tvar c = cos(theta);\r\n\t\ttex = vec2<f32>(dot(tex, vec2<f32>(c, -s)), dot(tex, vec2<f32>(s, c)));\r\n\t}\r\n\t\r\n\ttex = tex + center;\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\r\n\ttex = c3_normToSrcOrigin(tex);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"tint","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"color","type":"color","initial-value":[1,0,0],"interpolatable":true,"uniform":"tintColor","c2id":"red,green,blue"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Tint effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp vec3 tintColor;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\t\r\n\tgl_FragColor = front * vec4(tintColor.r, tintColor.g, tintColor.b, 1.0);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttintColor : vec3<f32>\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput {\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = front * vec4<f32>(shaderParams.tintColor, 1.0);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"tintmask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"color","type":"color","initial-value":[1,0,0],"interpolatable":true,"uniform":"tintColor","c2id":"red,green,blue"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Tint Mask effect\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform lowp vec3 tintColor;\r\n\r\nvoid main(void)\r\n{\r\n\t// Retrieve front and back pixels\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\tlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\r\n\t\r\n\tgl_FragColor = mix(back, back * vec4(tintColor.r, tintColor.g, tintColor.b, 1.0), fronta);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\ttintColor : vec3<f32>\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\tvar back : vec4<f32> = textureSample(textureBack, samplerBack, c3_getBackUV(input.fragPos.xy, textureBack));\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = mix(back, back * vec4<f32>(shaderParams.tintColor, 1.0), fronta);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"toon","category":"color","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"threshold","type":"percent","initial-value":0.2,"interpolatable":true,"uniform":"threshold"},{"id":"levels","type":"float","initial-value":10,"interpolatable":true,"uniform":"quantizationLevels"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Toon effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\n\r\nprecision highmedp float;\r\nuniform highmedp vec2 pixelSize;\r\nuniform highmedp float threshold;\r\nuniform highmedp float quantizationLevels;\r\n\r\nvoid main(void)\r\n{\r\n\tvec4 front = texture2D(samplerFront, vTex);\r\n\r\n\tfloat dx = pixelSize.x;\r\n\tfloat dy = pixelSize.y;\r\n\t\r\n    float bottomLeftIntensity = texture2D(samplerFront, vTex + vec2(-dx, dy)).r;\r\n    float topRightIntensity = texture2D(samplerFront, vTex + vec2(dx, -dy)).r;\r\n    float topLeftIntensity = texture2D(samplerFront, vTex + vec2(-dx, -dy)).r;\r\n    float bottomRightIntensity = texture2D(samplerFront, vTex + vec2(dx, dy)).r;\r\n    float leftIntensity = texture2D(samplerFront, vTex + vec2(-dx, 0.0)).r;\r\n    float rightIntensity = texture2D(samplerFront, vTex + vec2(dx, 0.0)).r;\r\n    float bottomIntensity = texture2D(samplerFront, vTex + vec2(0.0, dy)).r;\r\n    float topIntensity = texture2D(samplerFront, vTex + vec2(0.0, -dy)).r;\r\n\tfloat h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\r\n\tfloat v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\r\n\r\n\tfloat mag = length(vec2(h, v));\r\n\r\n\tvec3 posterized = floor((front.rgb * (quantizationLevels-1.0)) + 0.5) / (quantizationLevels-1.0);\r\n\r\n\tfloat thresholdTest = 1.0 - step(threshold, mag);\r\n\r\n\tgl_FragColor = vec4(posterized * thresholdTest, front.a);\r\n}\r\n","wgsl":"// Toon effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tthreshold : f32,\r\n\tquantizationLevels : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar dx : f32 = pixelSize.x;\r\n\tvar dy : f32 = pixelSize.y;\r\n\t\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\t\r\n\tvar bottomLeftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, dy)).r;\r\n    var topRightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, -dy)).r;\r\n    var topLeftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, -dy)).r;\r\n    var bottomRightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, dy)).r;\r\n    var leftIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(-dx, 0.0)).r;\r\n    var rightIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(dx, 0.0)).r;\r\n    var bottomIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, dy)).r;\r\n    var topIntensity : f32 = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, -dy)).r;\r\n\t\r\n\tvar h : f32 = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\r\n\tvar v : f32 = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\r\n\t\r\n\tvar mag : f32 = length(vec2<f32>(h, v));\r\n\tvar posterized : vec3<f32> = floor((front.rgb * (shaderParams.quantizationLevels - 1.0)) + 0.5) / (shaderParams.quantizationLevels - 1.0);\r\n\t\r\n\tvar thresholdTest = 1.0 - step(shaderParams.threshold, mag);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(posterized * thresholdTest, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"vibrance","category":"color","author":"Evan Wallace","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"vibrance","type":"percent","initial-value":1,"interpolatable":true,"uniform":"vibrance"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Vibrance effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform lowp float vibrance;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float average = front.r / 3.0 + front.g / 3.0 + front.b / 3.0;\r\n\tlowp float max_ = max(front.r, max(front.g, front.b));\r\n\tlowp float amount = (max_ - average) * (vibrance * -3.0);\r\n\tfront.rgb = mix(front.rgb, vec3(max_), amount);\r\n\tgl_FragColor = front;\r\n}\r\n","wgsl":"// Vibrance effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tvibrance : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\r\n\tvar average : f32 = (front.r + front.g + front.b) / 3.0;\r\n\tvar max_ : f32 = max(front.r, max(front.g, front.b));\r\n\tvar amount = (max_ - average) * (shaderParams.vibrance * -3.0);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(mix(front.rgb, vec3<f32>(max_), amount), front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"vignette","category":"color","author":"Brad Larson","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":true,"animated":false,"extend-box":{"horizontal":0,"vertical":0},"parameters":[{"id":"start-radius","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"vignetteStart"},{"id":"end-radius","type":"percent","initial-value":0.75,"interpolatable":true,"uniform":"vignetteEnd"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Vignette effect\r\n// Based on code from GPUImage: https://github.com/BradLarson/GPUImage\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\n\r\nuniform mediump float vignetteStart;\r\nuniform mediump float vignetteEnd;\r\n\r\nvoid main(void)\r\n{\t\r\n\tlowp vec4 front = texture2D(samplerFront, vTex);\r\n\tlowp float a = front.a;\r\n\t\r\n\tif (a != 0.0)\r\n\t\tfront.rgb /= a;\r\n\t\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n    lowp float d = distance(tex, vec2(0.5, 0.5));\r\n    front.rgb *= smoothstep(vignetteEnd, vignetteStart, d);\r\n\tfront.rgb *= a;\r\n\t\r\n    gl_FragColor = front;\r\n}\r\n","wgsl":"// Vibrance effect\r\n// Based on code from glfx.js: https://github.com/evanw/glfx.js\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tvignetteStart : f32,\r\n\tvignetteEnd : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet center : vec2<f32> = vec2<f32>(0.5);\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar front : vec4<f32> = c3_unpremultiply(textureSample(textureFront, samplerFront, input.fragUV));\r\n\tvar rgb : vec3<f32> = front.rgb;\r\n\t\t\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar d : f32 = distance(tex, center);\r\n\trgb = rgb * smoothstep(shaderParams.vignetteEnd, shaderParams.vignetteStart, d);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = vec4<f32>(rgb * front.a, front.a);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warp","category":"distortion","author":"Scirra","is-deprecated":true,"supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"x-frequency","type":"float","initial-value":25,"interpolatable":true,"uniform":"freqX"},{"id":"y-frequency","type":"float","initial-value":25,"interpolatable":true,"uniform":"freqY"},{"id":"x-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampX"},{"id":"y-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampY"},{"id":"x-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedX"},{"id":"y-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\n\r\nuniform mediump float freqX;\r\nuniform mediump float freqY;\r\nuniform mediump float ampX;\r\nuniform mediump float ampY;\r\nuniform mediump float speedX;\r\nuniform mediump float speedY;\r\n\r\nvoid main(void)\r\n{\r\n\t// retrieve tex in normalised [0, 1] range regardless of source rect\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\tmediump float aspect = pixelSize.y / pixelSize.x;\r\n\t\r\n\tmediump vec2 p = vTex;\r\n    p.x += (cos(tex.y * freqX / (pixelSize.x * 750.0) + (seconds * speedX)) * ampX * devicePixelRatio * layerScale * pixelSize.x);\r\n\tp.y += (sin(tex.x * freqY * aspect / (pixelSize.y * 750.0) + (seconds * speedY)) * ampY * devicePixelRatio * layerScale * pixelSize.y);\r\n\t\r\n\tp = clamp(p, min(srcStart, srcEnd), max(srcStart, srcEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, p);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfreqX : f32,\r\n\tfreqY : f32,\r\n\tampX : f32,\r\n\tampY : f32,\r\n\tspeedX : f32,\r\n\tspeedY : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi2 : f32 = 6.283185307179586;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\tvar aspect : f32 = pixelSize.y / pixelSize.x;\r\n\t\r\n\t// Process warp\r\n\tvar p : vec2<f32> = input.fragUV + vec2<f32>(\r\n\t\tcos(tex.y * shaderParams.freqX / (pixelSize.x * 750.0) + (c3Params.seconds * shaderParams.speedX)) * shaderParams.ampX * c3Params.devicePixelRatio * c3Params.layerScale * pixelSize.x,\r\n\t\tsin(tex.x * shaderParams.freqY * aspect / (pixelSize.y * 750.0) + (c3Params.seconds * shaderParams.speedY)) * shaderParams.ampY * c3Params.devicePixelRatio * c3Params.layerScale * pixelSize.y\r\n\t);\r\n\t\r\n\t// Clamp to source area\r\n\tp = c3_clampToSrc(p);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, p);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warpobject","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"x-frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"freqX"},{"id":"y-frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"freqY"},{"id":"x-amplitude","type":"float","initial-value":10,"interpolatable":true,"uniform":"ampX"},{"id":"y-amplitude","type":"float","initial-value":10,"interpolatable":true,"uniform":"ampY"},{"id":"x-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedX"},{"id":"y-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp object effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\n\r\nuniform mediump float freqX;\r\nuniform mediump float freqY;\r\nuniform mediump float ampX;\r\nuniform mediump float ampY;\r\nuniform mediump float speedX;\r\nuniform mediump float speedY;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float _2pi = 2.0 * 3.14159265359;\r\n\t\r\n\t// Get normalised texture co-ordinates in original source rect\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\r\n\t\r\n\t// Process warp\r\n\tmediump vec2 p = vTex;\r\n\tp.x += cos(n.y * _2pi * freqY + seconds * speedY * _2pi) * ampY * pixelSize.x * devicePixelRatio * layerScale;\r\n\tp.y += sin(n.x * _2pi * freqX + seconds * speedX * _2pi) * ampX * pixelSize.y * devicePixelRatio * layerScale;\r\n\t\r\n\t// Clamp to source area\r\n\tp = clamp(p, min(srcStart, srcEnd), max(srcStart, srcEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, p);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfreqX : f32,\r\n\tfreqY : f32,\r\n\tampX : f32,\r\n\tampY : f32,\r\n\tspeedX : f32,\r\n\tspeedY : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi2 : f32 = 6.283185307179586;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\t\r\n\t// Get normalised texture co-ordinates in original source rect\r\n\tvar n : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\t\r\n\t// Process warp\r\n\tvar p : vec2<f32> = input.fragUV + vec2<f32>(\r\n\t\tcos(n.y * pi2 * shaderParams.freqY + c3Params.seconds * shaderParams.speedY * pi2) * shaderParams.ampY * pixelSize.x * c3Params.devicePixelRatio * c3Params.layerScale,\r\n\t\tsin(n.x * pi2 * shaderParams.freqX + c3Params.seconds * shaderParams.speedX * pi2) * shaderParams.ampX * pixelSize.y * c3Params.devicePixelRatio * c3Params.layerScale\r\n\t);\r\n\t\r\n\t// Clamp to source area\r\n\tp = c3_clampToSrc(p);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, p);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warpobjectmask","category":"mask","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"x-frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"freqX"},{"id":"y-frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"freqY"},{"id":"x-amplitude","type":"float","initial-value":10,"interpolatable":true,"uniform":"ampX"},{"id":"y-amplitude","type":"float","initial-value":10,"interpolatable":true,"uniform":"ampY"},{"id":"x-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedX"},{"id":"y-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp layout effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\n\r\nuniform mediump float freqX;\r\nuniform mediump float freqY;\r\nuniform mediump float ampX;\r\nuniform mediump float ampY;\r\nuniform mediump float speedX;\r\nuniform mediump float speedY;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float _2pi = 2.0 * 3.14159265359;\r\n\t\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\t\r\n\t// Get normalised texture co-ordinates in original source rect\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\r\n\t\r\n\t// Process warp\r\n\tmediump vec2 p = mix(destStart, destEnd, tex);\r\n\tp.x += cos(n.y * _2pi * freqY + seconds * speedY * _2pi) * ampY * pixelSize.x * devicePixelRatio * layerScale * fronta;\r\n\tp.y += sin(n.x * _2pi * freqX + seconds * speedX * _2pi) * ampX * pixelSize.y * devicePixelRatio * layerScale * fronta;\r\n\t\r\n\tp = clamp(p, min(destStart, destEnd), max(destStart, destEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerBack, p);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfreqX : f32,\r\n\tfreqY : f32,\r\n\tampX : f32,\r\n\tampY : f32,\r\n\tspeedX : f32,\r\n\tspeedY : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi2 : f32 = 6.283185307179586;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\r\n\tvar fronta : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\r\n\r\n\tvar n : vec2<f32> = c3_srcOriginToNorm(input.fragUV);\r\n\r\n\t// Process warp\r\n\tvar p : vec2<f32> = c3_getBackUV(input.fragPos.xy, textureBack) + vec2<f32>(\r\n\t\tcos(n.y * pi2 * shaderParams.freqY + c3Params.seconds * shaderParams.speedY * pi2) * shaderParams.ampY * pixelSize.x * c3Params.devicePixelRatio * c3Params.layerScale * fronta,\r\n\t\tsin(n.x * pi2 * shaderParams.freqX + c3Params.seconds * shaderParams.speedX * pi2) * shaderParams.ampX * pixelSize.y * c3Params.devicePixelRatio * c3Params.layerScale * fronta\r\n\t);\r\n\r\n\tp = c3_clampToDest(p);\r\n\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureBack, samplerBack, p);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warplayout","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"x-period","type":"float","initial-value":60,"interpolatable":true,"uniform":"periodX"},{"id":"y-period","type":"float","initial-value":60,"interpolatable":true,"uniform":"periodY"},{"id":"x-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampX"},{"id":"y-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampY"},{"id":"x-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedX"},{"id":"y-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp layout effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform mediump vec2 layoutStart;\r\nuniform mediump vec2 layoutEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\n\r\nuniform mediump float periodX;\r\nuniform mediump float periodY;\r\nuniform mediump float ampX;\r\nuniform mediump float ampY;\r\nuniform mediump float speedX;\r\nuniform mediump float speedY;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump float _2pi = 2.0 * 3.14159265359;\r\n\t\r\n\t// Get normalised texture co-ordinates in original source rect, and map those to layout co-ordinates\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\r\n\tmediump vec2 l = mix(layoutStart, layoutEnd, n);\r\n\t\r\n\t// Process warp\r\n\tmediump vec2 p = vTex;\r\n\tp.x += cos((l.y / periodY) * _2pi + seconds * speedY * _2pi) * ampY * pixelSize.x * devicePixelRatio * layerScale;\r\n\tp.y += sin((l.x / periodX) * _2pi + seconds * speedX * _2pi) * ampX * pixelSize.y * devicePixelRatio * layerScale;\r\n\t\r\n\t// Clamp to source area\r\n\tp = clamp(p, min(srcStart, srcEnd), max(srcStart, srcEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, p);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tperiodX : f32,\r\n\tperiodY : f32,\r\n\tampX : f32,\r\n\tampY : f32,\r\n\tspeedX : f32,\r\n\tspeedY : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi2 : f32 = 6.283185307179586;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\tvar l : vec2<f32> = c3_getLayoutPos(input.fragUV);\r\n\t\r\n\t// Process warp\r\n\tvar p : vec2<f32> = input.fragUV + vec2<f32>(\r\n\t\tcos((l.y / shaderParams.periodY) * pi2 + c3Params.seconds * shaderParams.speedY * pi2) * shaderParams.ampY * pixelSize.x * c3Params.devicePixelRatio * c3Params.layerScale,\r\n\t\tsin((l.x / shaderParams.periodX) * pi2 + c3Params.seconds * shaderParams.speedX * pi2) * shaderParams.ampX * pixelSize.y * c3Params.devicePixelRatio * c3Params.layerScale\r\n\t);\r\n\t\r\n\t// Clamp to source area\r\n\tp = c3_clampToSrc(p);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, p);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warpmask","category":"mask","author":"Scirra","is-deprecated":true,"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"x-frequency","type":"float","initial-value":25,"interpolatable":true,"uniform":"freqX"},{"id":"y-frequency","type":"float","initial-value":25,"interpolatable":true,"uniform":"freqY"},{"id":"x-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampX"},{"id":"y-amplitude","type":"float","initial-value":5,"interpolatable":true,"uniform":"ampY"},{"id":"x-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedX"},{"id":"y-speed","type":"float","initial-value":1,"interpolatable":true,"uniform":"speedY"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp mask effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\nuniform mediump float devicePixelRatio;\r\nuniform mediump float layerScale;\r\n\r\nuniform mediump float freqX;\r\nuniform mediump float freqY;\r\nuniform mediump float ampX;\r\nuniform mediump float ampY;\r\nuniform mediump float speedX;\r\nuniform mediump float speedY;\r\n\r\nvoid main(void)\r\n{\r\n\tlowp float fronta = texture2D(samplerFront, vTex).a;\r\n\t\r\n\t// retrieve tex in normalised [0, 1] range regardless of source rect\r\n\tmediump vec2 srcSize = srcEnd - srcStart;\r\n\tmediump vec2 tex = ((vTex - srcStart) / srcSize);\r\n\tmediump float aspect = pixelSize.y / pixelSize.x;\r\n\t\r\n\tmediump vec2 p =  mix(destStart, destEnd, tex);\r\n    p.x += (cos(tex.y * freqX / (pixelSize.x * 750.0) + (seconds * speedX)) * ampX * devicePixelRatio * layerScale * pixelSize.x) * fronta;\r\n\tp.y += (sin(tex.x * freqY * aspect / (pixelSize.y * 750.0) + (seconds * speedY)) * ampY * devicePixelRatio * layerScale * pixelSize.y) * fronta;\r\n\t\r\n\tp = clamp(p, min(destStart, destEnd), max(destStart, destEnd));\r\n\t\r\n\tgl_FragColor = texture2D(samplerBack, p);\r\n}\r\n","wgsl":""},{"json":{"id":"warpradial","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":30,"vertical":30},"parameters":[{"id":"frequency","type":"float","initial-value":12,"interpolatable":true,"uniform":"freq"},{"id":"amplitude","type":"percent","initial-value":0.05,"interpolatable":true,"uniform":"amp"},{"id":"speed","type":"float","initial-value":2,"interpolatable":true,"uniform":"speed"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp radial effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform highmedp float seconds;\r\n\r\nuniform mediump float freq;\r\nuniform mediump float amp;\r\nuniform mediump float speed;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 tex = (vTex - srcOriginStart) / srcOriginSize;\r\n\ttex = tex * 2.0 - 1.0;\r\n\t\t\r\n\tmediump float d = length(tex);\r\n\tmediump float a = atan(tex.y, tex.x);\r\n\t\r\n\ta += sin(a * freq + (seconds * speed)) * amp;\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\r\n\ttex = clamp(tex, 0.0, 1.0);\r\n\ttex = tex * srcOriginSize + srcOriginStart;\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfreq : f32,\r\n\tamp : f32,\r\n\tspeed : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar tex = c3_srcOriginToNorm(input.fragUV);\r\n\ttex = tex * 2.0 - 1.0;\r\n\t\r\n\tvar d : f32 = length(tex);\r\n\tvar a = atan2(tex.y, tex.x);\r\n\t\r\n\ta = a + sin(a * shaderParams.freq + (c3Params.seconds * shaderParams.speed)) * shaderParams.amp;\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\r\n\ttex = c3_normToSrcOrigin(tex);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"warpripple","category":"distortion","author":"Scirra","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":50,"vertical":50},"parameters":[{"id":"frequency","type":"float","initial-value":3,"interpolatable":true,"uniform":"freq"},{"id":"amplitude","type":"percent","initial-value":0.03,"interpolatable":true,"uniform":"amp"},{"id":"speed","type":"float","initial-value":-2,"interpolatable":true,"uniform":"speed"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Warp Ripple effect\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcOriginStart;\r\nuniform mediump vec2 srcOriginEnd;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\n\r\nuniform mediump float freq;\r\nuniform mediump float amp;\r\nuniform mediump float speed;\r\n\r\nconst mediump float PI = 3.1415926;\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\r\n\tmediump vec2 tex = (vTex - srcOriginStart) / srcOriginSize;\r\n\ttex = tex * 2.0 - 1.0;\r\n\t\t\r\n\tmediump float d = length(tex);\r\n\tmediump float a = atan(tex.y, tex.x);\r\n\t\r\n\td += sin((d * 2.0 * PI) * freq / (pixelSize.x * 750.0) + (seconds * speed)) * amp * (pixelSize.x * 750.0);\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\r\n\ttex = clamp(tex, 0.0, 1.0);\r\n\ttex = tex * srcOriginSize + srcOriginStart;\r\n\t\r\n\tgl_FragColor = texture2D(samplerFront, tex);\r\n}\r\n","wgsl":"/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tfreq : f32,\r\n\tamp : f32,\r\n\tspeed : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi : f32 = 3.1415926;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\r\n\t\r\n\tvar tex = c3_srcOriginToNorm(input.fragUV);\r\n\ttex = tex * 2.0 - 1.0;\r\n\t\r\n\tvar d : f32 = length(tex);\r\n\tvar a = atan2(tex.y, tex.x);\r\n\t\r\n\td = d + sin((d * 2.0 * pi) * shaderParams.freq / (pixelSize.x * 750.0) + (c3Params.seconds * shaderParams.speed)) * shaderParams.amp * (pixelSize.x * 750.0);\r\n\t\r\n\ttex.x = cos(a) * d;\r\n\ttex.y = sin(a) * d;\r\n\t\r\n\ttex = (tex + 1.0) / 2.0;\r\n\ttex = c3_clamp2(tex, 0.0, 1.0);\r\n\ttex = c3_normToSrcOrigin(tex);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, tex);\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"water","category":"distortion","author":"Viktor Korsun","supported-renderers":["webgl","webgpu"],"blends-background":false,"cross-sampling":false,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":40,"vertical":40},"parameters":[{"id":"speed","type":"percent","initial-value":0.1,"interpolatable":true,"uniform":"speed"},{"id":"x-speed","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"speed_x"},{"id":"y-speed","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"speed_y"},{"id":"intensity","type":"float","initial-value":3,"interpolatable":true,"uniform":"intensity"},{"id":"frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"frequency"},{"id":"angle","type":"float","initial-value":7,"interpolatable":true,"uniform":"angle"},{"id":"delta","type":"float","initial-value":20,"interpolatable":true,"uniform":"delta"},{"id":"reflectivity","type":"float","initial-value":400,"interpolatable":true,"uniform":"intence"},{"id":"emboss","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"emboss"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Water effect\r\n// Based on code by Viktor Korsun\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\n\r\nprecision mediump float;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\n\r\nconst float PI = 3.1415926535897932;\r\n\r\n// speed\r\nuniform float speed;\r\nuniform float speed_x;\r\nuniform float speed_y;\r\n\r\n// geometry\r\nuniform float intensity;\r\nconst float steps = 8.0;\r\nuniform float frequency;\r\nuniform float angle; // better when a prime\r\n\r\n// reflection and emboss\r\nuniform float delta;\r\nuniform float intence;\r\nuniform float emboss;\r\n\r\nfloat col(vec2 coord)\r\n{\r\n\tfloat delta_theta = 2.0 * PI / angle;\r\n\tfloat col = 0.0;\r\n\tfloat theta = 0.0;\r\n\tfor (float i = 0.0; i < steps; i++)\r\n\t{\r\n\t\tvec2 adjc = coord;\r\n\t\ttheta = delta_theta*i;\r\n\t\tadjc.x += cos(theta)*seconds*speed + seconds * speed_x;\r\n\t\tadjc.y -= sin(theta)*seconds*speed - seconds * speed_y;\r\n\t\tcol = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;\r\n\t}\r\n\r\n\treturn cos(col);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\tvec2 p = tex, c1 = p, c2 = p;\r\n\tfloat cc1 = col(c1);\r\n\r\n\tc2.x += (1.0 / pixelSize.x) / delta;\r\n\tfloat dx = emboss*(cc1-col(c2))/delta;\r\n\r\n\tc2.x = p.x;\r\n\tc2.y += (1.0 / pixelSize.y) / delta;\r\n\tfloat dy = emboss*(cc1-col(c2))/delta;\r\n\r\n\tc1.x += dx;\r\n\tc1.y = -(c1.y+dy);\r\n\r\n\tfloat alpha = 1.+dot(dx,dy)*intence;\r\n\tc1.y = -c1.y;\r\n\tc1 = clamp(c1, 0.0, 1.0);\r\n\tgl_FragColor = texture2D(samplerFront, mix(srcStart, srcEnd, c1)) * alpha;\r\n}\r\n","wgsl":"// Water effect\r\n// Based on code by Viktor Korsun\r\n\r\n/////////////////////////////////////////////////////////\r\n// Texture and sampler\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tspeed : f32,\r\n\tspeed_x : f32,\r\n\tspeed_y : f32,\r\n\tintensity : f32,\r\n\tfrequency : f32,\r\n\tangle : f32,\r\n\tdelta : f32,\r\n\tintence : f32,\r\n\temboss : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi : f32 = 3.1415926535897932;\r\nlet steps = 8.0;\r\n\r\nfn col(coord : vec2<f32>) -> f32\r\n{\r\n\tvar delta_theta : f32 = 2.0 * pi / shaderParams.angle;\r\n\tvar col : f32 = 0.0;\r\n\tvar theta : f32 = 0.0;\r\n\tfor (var i : f32 = 0.0; i < steps; i = i + 1.0)\r\n\t{\r\n\t\tvar adjc : vec2<f32> = coord;\r\n\t\ttheta = delta_theta * i;\r\n\t\tadjc.x = adjc.x + cos(theta) * c3Params.seconds * shaderParams.speed + c3Params.seconds * shaderParams.speed_x;\r\n\t\tadjc.y = adjc.y - (sin(theta) * c3Params.seconds * shaderParams.speed - c3Params.seconds * shaderParams.speed_y);\r\n\t\tcol = col + cos((adjc.x * cos(theta) - adjc.y * sin(theta)) * shaderParams.frequency) * shaderParams.intensity;\r\n\t}\r\n\r\n\treturn cos(col);\r\n}\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar texSize : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\r\n\tvar p : vec2<f32> = tex;\r\n\tvar c1 : vec2<f32> = tex;\r\n\tvar c2 : vec2<f32> = tex;\r\n\tvar cc1 : f32 = col(c1);\r\n\r\n\tc2.x = c2.x + texSize.x / shaderParams.delta;\r\n\tvar dx : f32 = shaderParams.emboss * (cc1 - col(c2)) / shaderParams.delta;\r\n\r\n\tc2.x = p.x;\r\n\tc2.y = c2.y + texSize.y / shaderParams.delta;\r\n\tvar dy : f32 = shaderParams.emboss * (cc1 - col(c2)) / shaderParams.delta;\r\n\r\n\tc1.x = c1.x + dx;\r\n\tc1.y = -(c1.y + dy);\r\n\r\n\tvar alpha : f32 = 1.0 + dx * dy * shaderParams.intence;\r\n\tc1.y = -c1.y;\r\n\tc1 = c3_clamp2(c1, 0.0, 1.0);\r\n\t\r\n\tvar output : FragmentOutput;\r\n\toutput.color = textureSample(textureFront, samplerFront, mix(c3Params.srcStart, c3Params.srcEnd, c1)) * alpha;\r\n\treturn output;\r\n}\r\n"},{"json":{"id":"waterbg","category":"distortion","author":"Viktor Korsun","supported-renderers":["webgl","webgpu"],"blends-background":true,"cross-sampling":true,"preserves-opaqueness":false,"animated":true,"extend-box":{"horizontal":40,"vertical":40},"parameters":[{"id":"speed","type":"percent","initial-value":0.1,"interpolatable":true,"uniform":"speed"},{"id":"x-speed","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"speed_x"},{"id":"y-speed","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"speed_y"},{"id":"intensity","type":"float","initial-value":3,"interpolatable":true,"uniform":"intensity"},{"id":"frequency","type":"float","initial-value":4,"interpolatable":true,"uniform":"frequency"},{"id":"angle","type":"float","initial-value":7,"interpolatable":true,"uniform":"angle"},{"id":"delta","type":"float","initial-value":20,"interpolatable":true,"uniform":"delta"},{"id":"reflectivity","type":"float","initial-value":400,"interpolatable":true,"uniform":"intence"},{"id":"emboss","type":"percent","initial-value":0.3,"interpolatable":true,"uniform":"emboss"}]},"glsl":"/////////////////////////////////////////////////////////\r\n// Water background effect\r\n// Based on code by Viktor Korsun\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n#define highmedp highp\r\n#else\r\n#define highmedp mediump\r\n#endif\r\n\r\nvarying mediump vec2 vTex;\r\nuniform lowp sampler2D samplerFront;\r\nuniform mediump vec2 srcStart;\r\nuniform mediump vec2 srcEnd;\r\nuniform lowp sampler2D samplerBack;\r\nuniform mediump vec2 destStart;\r\nuniform mediump vec2 destEnd;\r\n\r\nprecision mediump float;\r\nuniform highmedp float seconds;\r\nuniform mediump vec2 pixelSize;\r\n\r\nconst float PI = 3.1415926535897932;\r\n\r\n// speed\r\nuniform float speed;\r\nuniform float speed_x;\r\nuniform float speed_y;\r\n\r\n// geometry\r\nuniform float intensity;\r\nconst float steps = 8.0;\r\nuniform float frequency;\r\nuniform float angle; // better when a prime\r\n\r\n// reflection and emboss\r\nuniform float delta;\r\nuniform float intence;\r\nuniform float emboss;\r\n\r\nfloat col(vec2 coord)\r\n{\r\n\tfloat delta_theta = 2.0 * PI / angle;\r\n\tfloat col = 0.0;\r\n\tfloat theta = 0.0;\r\n\tfor (float i = 0.0; i < steps; i++)\r\n\t{\r\n\t\tvec2 adjc = coord;\r\n\t\ttheta = delta_theta*i;\r\n\t\tadjc.x += cos(theta)*seconds*speed + seconds * speed_x;\r\n\t\tadjc.y -= sin(theta)*seconds*speed - seconds * speed_y;\r\n\t\tcol = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;\r\n\t}\r\n\r\n\treturn cos(col);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\r\n\t\r\n\tvec2 p = tex, c1 = p, c2 = p;\r\n\tfloat cc1 = col(c1);\r\n\r\n\tc2.x += (1.0 / pixelSize.x) / delta;\r\n\tfloat dx = emboss*(cc1-col(c2))/delta;\r\n\r\n\tc2.x = p.x;\r\n\tc2.y += (1.0 / pixelSize.y) / delta;\r\n\tfloat dy = emboss*(cc1-col(c2))/delta;\r\n\r\n\tc1.x += dx;\r\n\tc1.y = -(c1.y+dy);\r\n\r\n\tfloat alpha = 1.+dot(dx,dy)*intence;\r\n\tc1.y = -c1.y;\r\n\tc1 = clamp(c1, 0.0, 1.0);\r\n\tlowp vec4 front = texture2D(samplerFront, mix(srcStart, srcEnd, c1)) * alpha;\r\n\tlowp vec4 result;\r\n\t\r\n\tif (front.a == 0.0)\r\n\t\tresult = front + texture2D(samplerBack, mix(destStart, destEnd, tex)) * (1.0 - front.a);\r\n\telse\r\n\t\tresult = front + texture2D(samplerBack, mix(destStart, destEnd, c1)) * (1.0 - front.a);\r\n\t\r\n\tgl_FragColor = result;\r\n}\r\n","wgsl":"// Water background effect\r\n// Based on code by Viktor Korsun\r\n\r\n/////////////////////////////////////////////////////////\r\n// Textures and samplers\r\n%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\r\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\r\n\r\n%%SAMPLERBACK_BINDING%% var samplerBack : sampler;\r\n%%TEXTUREBACK_BINDING%% var textureBack : texture_2d<f32>;\r\n\r\n/////////////////////////////////////////////////////////\r\n// Shader custom parameters\r\nstruct ShaderParams {\r\n\tspeed : f32,\r\n\tspeed_x : f32,\r\n\tspeed_y : f32,\r\n\tintensity : f32,\r\n\tfrequency : f32,\r\n\tangle : f32,\r\n\tdelta : f32,\r\n\tintence : f32,\r\n\temboss : f32\r\n};\r\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\r\n\r\n%%C3PARAMS_STRUCT%%\r\n%%C3_UTILITY_FUNCTIONS%%\r\n\r\n%%FRAGMENTINPUT_STRUCT%%\r\n%%FRAGMENTOUTPUT_STRUCT%%\r\n\r\nlet pi : f32 = 3.1415926535897932;\r\nlet steps = 8.0;\r\n\r\nfn col(coord : vec2<f32>) -> f32\r\n{\r\n\tvar delta_theta : f32 = 2.0 * pi / shaderParams.angle;\r\n\tvar col : f32 = 0.0;\r\n\tvar theta : f32 = 0.0;\r\n\tfor (var i : f32 = 0.0; i < steps; i = i + 1.0)\r\n\t{\r\n\t\tvar adjc : vec2<f32> = coord;\r\n\t\ttheta = delta_theta * i;\r\n\t\tadjc.x = adjc.x + cos(theta) * c3Params.seconds * shaderParams.speed + c3Params.seconds * shaderParams.speed_x;\r\n\t\tadjc.y = adjc.y - (sin(theta) * c3Params.seconds * shaderParams.speed - c3Params.seconds * shaderParams.speed_y);\r\n\t\tcol = col + cos((adjc.x * cos(theta) - adjc.y * sin(theta)) * shaderParams.frequency) * shaderParams.intensity;\r\n\t}\r\n\r\n\treturn cos(col);\r\n}\r\n\r\n/////////////////////////////////////////////////////////\r\n// Main method\r\n@stage(fragment)\r\nfn main(input : FragmentInput) -> FragmentOutput\r\n{\r\n\tvar texSize : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\r\n\tvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\r\n\r\n\tvar p : vec2<f32> = tex;\r\n\tvar c1 : vec2<f32> = tex;\r\n\tvar c2 : vec2<f32> = tex;\r\n\tvar cc1 : f32 = col(c1);\r\n\r\n\tc2.x = c2.x + texSize.x / shaderParams.delta;\r\n\tvar dx : f32 = shaderParams.emboss * (cc1 - col(c2)) / shaderParams.delta;\r\n\r\n\tc2.x = p.x;\r\n\tc2.y = c2.y + texSize.y / shaderParams.delta;\r\n\tvar dy : f32 = shaderParams.emboss * (cc1 - col(c2)) / shaderParams.delta;\r\n\r\n\tc1.x = c1.x + dx;\r\n\tc1.y = -(c1.y + dy);\r\n\r\n\tvar alpha : f32 = 1.0 + dx * dy * shaderParams.intence;\r\n\tc1.y = -c1.y;\r\n\tc1 = c3_clamp2(c1, 0.0, 1.0);\r\n\r\n\tvar front : vec4<f32> = textureSample(textureFront, samplerFront, mix(c3Params.srcStart, c3Params.srcEnd, c1));\r\n\r\n\tvar output : FragmentOutput;\r\n\tif (front.a == 0.0)\r\n\t{\r\n\t\toutput.color = textureSample(textureBack, samplerBack, mix(c3Params.destStart, c3Params.destEnd, tex));\r\n\t}\r\n\telse\r\n\t{\r\n\t\toutput.color =  textureSample(textureBack, samplerBack, mix(c3Params.destStart, c3Params.destEnd, c1));\r\n\t}\r\n\r\n\toutput.color = output.color * (1.0 - front.a) + front;\r\n\treturn output;\r\n}\r\n"}]}